{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Sunday? Sunday is a code generator and family of client libraries for implementing generated REST clients and server stubs from RAML . Features Sunday focuses on implmenting a consistent set of advanced REST features across client & server libraries and languages. The key features Sunday provides: Detailed Error Responses via Problems Efficient Notifications via Server-Sent Events Dynamic Content-Type Negotiation Alternative Request/Response Encodings Date/Time Data Types Simple & Beautiful Code Generator The binding technology for Sunday is the Generator which generates clients for all of Sunday's client library implementations. In addition, the generator also supports generating server and client interfaces for JAX-RS that are customizable for a number of implementations (e.g Quarkus ). Client Libraries Sunday provides dedicated client libraries for the following languages: Swift client library for Apple platforms macOS , iOS , iPadOS , WatchOS Kotlin client library for JVM platforms Java, Android TypeScript client library for Web platforms Browsers (Chrome , Safari , Firefox) Concurrency The client library implementations use the latest concurrency features of their respective languages to make their usage effeciant and enjoyable. Concurrency featuers like async / await and coroutines are supported where available. Client Generation The Sunday code generator generates client APIs targeting the following client libraries: Sunday JAX-RS ( Java ) Server Generation The Sunday code generator generates server stubs for the following standards based libraries: JAX-RS ( Java )","title":"About"},{"location":"#what-is-sunday","text":"Sunday is a code generator and family of client libraries for implementing generated REST clients and server stubs from RAML .","title":"What is Sunday?"},{"location":"#features","text":"Sunday focuses on implmenting a consistent set of advanced REST features across client & server libraries and languages. The key features Sunday provides: Detailed Error Responses via Problems Efficient Notifications via Server-Sent Events Dynamic Content-Type Negotiation Alternative Request/Response Encodings Date/Time Data Types Simple & Beautiful Code","title":"Features"},{"location":"#generator","text":"The binding technology for Sunday is the Generator which generates clients for all of Sunday's client library implementations. In addition, the generator also supports generating server and client interfaces for JAX-RS that are customizable for a number of implementations (e.g Quarkus ).","title":"Generator"},{"location":"#client-libraries","text":"Sunday provides dedicated client libraries for the following languages: Swift client library for Apple platforms macOS , iOS , iPadOS , WatchOS Kotlin client library for JVM platforms Java, Android TypeScript client library for Web platforms Browsers (Chrome , Safari , Firefox)","title":"Client Libraries"},{"location":"#concurrency","text":"The client library implementations use the latest concurrency features of their respective languages to make their usage effeciant and enjoyable. Concurrency featuers like async / await and coroutines are supported where available.","title":"Concurrency"},{"location":"#client-generation","text":"The Sunday code generator generates client APIs targeting the following client libraries: Sunday JAX-RS ( Java )","title":"Client Generation"},{"location":"#server-generation","text":"The Sunday code generator generates server stubs for the following standards based libraries: JAX-RS ( Java )","title":"Server Generation"},{"location":"alternative-request-response-encodings/","text":"Alternative Request/Response Encodings Sunday supports alternative request & response encodings to allow choosing between performance, efficiency and debuggability. Coupled with Dynamic Content-Type Negotiation , Sunday makes it easy to switch default encodings as needed or use specific encodings only on some methods. CBOR CBOR (RFC 7807) is a binary encoding format that closely matchees JSON. CBOR's close match to JSON means that using CBOR allows seemless switching between CBOR & JSON. When debuggability or platform support is important JSON can be used. While CBOR can be used when performance is of primary concern.","title":"Alternative Request/Response Encodings"},{"location":"alternative-request-response-encodings/#alternative-requestresponse-encodings","text":"Sunday supports alternative request & response encodings to allow choosing between performance, efficiency and debuggability. Coupled with Dynamic Content-Type Negotiation , Sunday makes it easy to switch default encodings as needed or use specific encodings only on some methods.","title":"Alternative Request/Response Encodings"},{"location":"alternative-request-response-encodings/#cbor","text":"CBOR (RFC 7807) is a binary encoding format that closely matchees JSON. CBOR's close match to JSON means that using CBOR allows seemless switching between CBOR & JSON. When debuggability or platform support is important JSON can be used. While CBOR can be used when performance is of primary concern.","title":"CBOR"},{"location":"client-code/","text":"Simple & Beautiful Code Sunday client libraries are designed to enable Sunday's Generator to produce client APIs that are comprised of a small amount of code that is efficient and eschews dynamic code (i.e. reflection, proxies, etc.) for static generation. Reduced Regeneration The generated clients delegate the bulk of their service method implementations to request factory interfaces to simplify the generated client code. This simplification of client code goes beyond making the code simple and easy to read, it reduces the chances that clients need to be regenerated when the client libraries are upggraded for bug fixes releases. Concurrency The generated client APIs are built on the client implementations that use the latest concurrency features of their respective languages. Concurrency features like async / await and coroutines are supported when available. For example, Kotlin service methods are generated as suspend functions with regular return types and TypeScript service methods are generated as async functions with return values wrapped in a Promise . Poetry Sunday Generator aims to produce code that looks like it was written by you. To that end it does not use traditional template based code generation, instead it uses \"Poet\" code generation libraries that produce great looking, simple and well formatted code. For generating each client or server it uses either KotlinPoet , JavaPoet , SwiftPoet , or TypeScriptPoet .","title":"Simple & Beautiful Code"},{"location":"client-code/#simple-beautiful-code","text":"Sunday client libraries are designed to enable Sunday's Generator to produce client APIs that are comprised of a small amount of code that is efficient and eschews dynamic code (i.e. reflection, proxies, etc.) for static generation.","title":"Simple &amp; Beautiful Code"},{"location":"client-code/#reduced-regeneration","text":"The generated clients delegate the bulk of their service method implementations to request factory interfaces to simplify the generated client code. This simplification of client code goes beyond making the code simple and easy to read, it reduces the chances that clients need to be regenerated when the client libraries are upggraded for bug fixes releases.","title":"Reduced Regeneration"},{"location":"client-code/#concurrency","text":"The generated client APIs are built on the client implementations that use the latest concurrency features of their respective languages. Concurrency features like async / await and coroutines are supported when available. For example, Kotlin service methods are generated as suspend functions with regular return types and TypeScript service methods are generated as async functions with return values wrapped in a Promise .","title":"Concurrency"},{"location":"client-code/#poetry","text":"Sunday Generator aims to produce code that looks like it was written by you. To that end it does not use traditional template based code generation, instead it uses \"Poet\" code generation libraries that produce great looking, simple and well formatted code. For generating each client or server it uses either KotlinPoet , JavaPoet , SwiftPoet , or TypeScriptPoet .","title":"Poetry"},{"location":"date-time-data-types/","text":"Date/Time Data Types Sunday has support for a consistent set of Date & Time related types across languages and libraries.","title":"Date/Time Data Types"},{"location":"date-time-data-types/#datetime-data-types","text":"Sunday has support for a consistent set of Date & Time related types across languages and libraries.","title":"Date/Time Data Types"},{"location":"dynamic-content-type-negotiation/","text":"Dynamic Content-Type Negotation Sunday has extensive support for dynamic content negotation. This feature allows clients to select the encoding method to use per method or per service or as defaults. Clients Sunday client implementations support standard formats like JSON, URL Encoded, Binary, etc. Additionally, client implementations allow easy extension by registering custom Media-Type encoders and/or decoders to handle any type imaginable wether it be standards based or custom. Servers Sunday server support for media-type negotiation relies on the underlying framework (e.g JAX-RS).","title":"Dynamic Content-Type Negotation"},{"location":"dynamic-content-type-negotiation/#dynamic-content-type-negotation","text":"Sunday has extensive support for dynamic content negotation. This feature allows clients to select the encoding method to use per method or per service or as defaults.","title":"Dynamic Content-Type Negotation"},{"location":"dynamic-content-type-negotiation/#clients","text":"Sunday client implementations support standard formats like JSON, URL Encoded, Binary, etc. Additionally, client implementations allow easy extension by registering custom Media-Type encoders and/or decoders to handle any type imaginable wether it be standards based or custom.","title":"Clients"},{"location":"dynamic-content-type-negotiation/#servers","text":"Sunday server support for media-type negotiation relies on the underlying framework (e.g JAX-RS).","title":"Servers"},{"location":"problems/","text":"Detailed Error Responses via Problems Sunday supports detailed error responses based on Problem Details for HTTP APIs (RFC 7807) . The support is complete and baked into the Generator as well each of the client library implementations and all generated server stubs. RAML The Sunday Generator extends RAML via annotations to support easy declaration and usage of problems in API definitions. Using Sunday's RAML annotations, problems can be defined globally and then methods can reference those problem defintions to easily add detailed responses without redeclaration. Clients Sunday client implementations map problem responses to language specific error types. For example, in Kotlin problems are deserialized as exceptions and the service methods throw the exception instead of returning a value, allowing consumers to catch exceptions explicitly and easily. Servers Sunday servers implementations suppoert the ability to throw (or otherwise return) language specific error types from method stub implementtions. For example, in Kotlin, problems types are generated from problem declarations as exceptions and the stub implementations are allowed to throw the exceptions as responses.","title":"Detailed Error Responses via Problems"},{"location":"problems/#detailed-error-responses-via-problems","text":"Sunday supports detailed error responses based on Problem Details for HTTP APIs (RFC 7807) . The support is complete and baked into the Generator as well each of the client library implementations and all generated server stubs.","title":"Detailed Error Responses via Problems"},{"location":"problems/#raml","text":"The Sunday Generator extends RAML via annotations to support easy declaration and usage of problems in API definitions. Using Sunday's RAML annotations, problems can be defined globally and then methods can reference those problem defintions to easily add detailed responses without redeclaration.","title":"RAML"},{"location":"problems/#clients","text":"Sunday client implementations map problem responses to language specific error types. For example, in Kotlin problems are deserialized as exceptions and the service methods throw the exception instead of returning a value, allowing consumers to catch exceptions explicitly and easily.","title":"Clients"},{"location":"problems/#servers","text":"Sunday servers implementations suppoert the ability to throw (or otherwise return) language specific error types from method stub implementtions. For example, in Kotlin, problems types are generated from problem declarations as exceptions and the stub implementations are allowed to throw the exceptions as responses.","title":"Servers"},{"location":"server-sent-events/","text":"Efficient Notifications via Server-Sent Events Sunday supports notifications systems via Server-Sent Events as a more efficent mechanism than resorting to WebSockets. Learn about Server-Sent Event Server-Sent Event Web API RAML The Sunday Generator extends RAML via annotations to support easily declaring methods that produce Server-Sent Events . Events are defined as RAML types and therefore types are generated in each language to easily consume strongly type events in clients and produce events in server implmentations. Clients Sunday client libraries ensure that an EventSource implementation is available to consume events. Each client library also provides reactive types that adapt EventSources to produce strongly typed events that are easily subscribed to and cancelled. Servers Sunday server implementations rely on the underlying frameworks to support Server-Sent Events. Events types are generated to easily produce events using the server framework.","title":"Efficient Notifications via Server-Sent Events"},{"location":"server-sent-events/#efficient-notifications-via-server-sent-events","text":"Sunday supports notifications systems via Server-Sent Events as a more efficent mechanism than resorting to WebSockets. Learn about Server-Sent Event Server-Sent Event Web API","title":"Efficient Notifications via Server-Sent Events"},{"location":"server-sent-events/#raml","text":"The Sunday Generator extends RAML via annotations to support easily declaring methods that produce Server-Sent Events . Events are defined as RAML types and therefore types are generated in each language to easily consume strongly type events in clients and produce events in server implmentations.","title":"RAML"},{"location":"server-sent-events/#clients","text":"Sunday client libraries ensure that an EventSource implementation is available to consume events. Each client library also provides reactive types that adapt EventSources to produce strongly typed events that are easily subscribed to and cancelled.","title":"Clients"},{"location":"server-sent-events/#servers","text":"Sunday server implementations rely on the underlying frameworks to support Server-Sent Events. Events types are generated to easily produce events using the server framework.","title":"Servers"},{"location":"generator/","text":"Sunday GENERATOR outfoxx/sunday-generator The Sunday Generator is a Kotlin / Java based code generator that generates client APIs targeted for Sunday implementations in a number of languages as well as Kotlin / JAX-RS clients & servers from RAML API definitions. Supported Languages & Frameworks Language Client Frameworks Server Frameworks Kotlin (JVM) Sunday , JAX-RS JAX-RS Swift Sunday TypeScript / JavaScript Sunday Executing Sunday Generator The generator has multiple ways it can be executed to make it easily accessible in many build environments. CLI Build Plugins CLI The generator has a complete command line interface that allows generating code for any target. Being written in Kotlin the generator is first delivered as an executable UberJar (a single jar with all dependencies). Additionally, the CLI can be executed as a docker container for environments wheere docker is avaiable and Java is not already available. Executable JAR Docker java -jar cli-all-1.1.0-beta.2.jar <target> <options> docker run outfoxx/sunday-generator:1.1.0-beta.2 <target> <options> Targets / Options Each available target has a specific set of allowed options which are detailed in the following table. Kotlin / Sunday Kotlin / JAX-RS Swift / Sunday TypeScript / Sunday Generates clients targeting the Kotlin language and the Sunday library. Target kotlin/sunday Options -out PATH required Output directory. -pkg <package-name> required Default package name. -model-pkg <package-name> Default model package name. If not specified '-pkg' is used. -service-pkg <package-name> Default service package. If not specified '-pkg' is used. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -disable Disables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings Generates clients or server stubs targeting the Kotlin language and the JAX-RS library. Target kotlin/jaxrs Options -out PATH required Output directory. -mode [client|server] required Target 'client' or 'server' for generated services. -pkg <package-name> required Default package name. -model-pkg <package-name> Default model package name. If not specified '-pkg' is used. -service-pkg <package-name> Default service package. If not specified '-pkg' is used. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -disable Disables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -coroutines Generate suspendable service methods for coroutine support. -reactive <type-name> Generic result type for reactive service. Specifying this option also enables the generation of reactive service methods. -explicit-security-parameters Include explicit security parameters in service methods. Generates clients targeting the Swift language and the Sunday library. Target swift/sunday Options -out PATH required Output directory. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: add-generated-annotation -disable Disables the given type generation option. Available Options: add-generated-annotation Generates clients targeting the TypeScript language and the Sunday library. Target typescript/sunday Options -out PATH required Output directory. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: jackson-decorators add-generated-annotation -disable Disables the given type generation option. Available Options: jackson-decorators add-generated-annotation Build Plugins In addition to the CLI, the genrator is delivered as build plugins for the following build tools: Gradle The Gradle plugin provides easy access for generating clients & server stubs for Kotlin/Java targets. The plugin allow you to create multiple \"generations\" each with their distinct sets of options to allow generating all of your code in a single project. Note Tht Gradle plugin only supports generating Kotlin & Java targets. Groovy DSL Kotlin DSL plugins { id \"io.outfoxx.sunday-generator\" version \"1.1.0-beta.2\" } sundayGenerations { // Create a generation named \"api\" api { // Input RAML files - default: \"src/main/raml/*.raml\" source = file ( \"src/main/raml/api.raml\" ) // Other RAML files dependencies - no default includes = fileTree ( \"src/main/raml\" ) // Output directory - default: \"generated/sources/sunday/<generation-name>\" outputDir = \"generated\" // TargetFramework.JAXRS or TargetFramework.Sunday - no default framework = TargetFramework . JAXRS // GenerationMode.Client or GenerationMode.Server - no default mode = GenerationMode . Client // Enable generation of model types - default: true generateModel = true // Enable generation of service types - default: true generateService = true // Default package name for model & service types - no default pkgName = \"com.example.api\" // Default package name for model types - no default modelPkgName = \"com.example.api.model\" // Default package name for service types - no default servicePkgName = \"com.example.api.services\" // Suffix to append to generated clients - default: \"API\" serviceSuffix = \"Client\" // Disable generation of bean validation annotations - default: true disableValidationConstraints = false // Disable generation of Jackson annotations - default: true disableJacksonAnnotations = false // Disable generation of model implementations - default: true disableModelImplementations = false // Enable generation of coroutines support in service methods - default: false coroutines = false // Enable generation of reactive response types in service methods - no default reactiveResponseType = \"CompletableFuture\" // Add security parameters to service methods - default: false explicitSecurityParameters = false // Set order of default media types defaultMediaTypes = listOf ( \"application/json\" ) } } plugins { id ( \"io.outfoxx.sunday-generator\" ) version ( \"1.1.0-beta.2\" ) } sundayGenerations { // Create a generation named \"api\" val api by creating { // Input RAML files - default: \"src/main/raml/*.raml\" source . set ( file ( \"src/main/raml/api.raml\" )) // Other RAML files dependencies - no default includes . set ( fileTree ( \"src/main/raml\" )) // Output directory - default: \"generated/sources/sunday/<generation-name>\" outputDir . set ( \"generated\" ) // TargetFramework.JAXRS or TargetFramework.Sunday - no default framework . set ( TargetFramework . JAXRS ) // GenerationMode.Client or GenerationMode.Server - no default mode . set ( GenerationMode . Client ) // Enable generation of model types - default: true generateModel . set ( true ) // Enable generation of service types - default: true generateService . set ( true ) // Default package name for model & service types - no default pkgName . set ( \"com.example.api\" ) // Default package name for model types - no default modelPkgName . set ( \"com.example.api.model\" ) // Default package name for service types - no default servicePkgName . set ( \"com.example.api.services\" ) // Suffix to append to generated clients - default: \"API\" serviceSuffix . set ( \"Client\" ) // Disable generation of bean validation annotations - default: true disableValidationConstraints . set ( false ) // Disable generation of Jackson annotations - default: true disableJacksonAnnotations . set ( false ) // Disable generation of model implementations - default: true disableModelImplementations . set ( false ) // Enable generation of coroutines support in service methods - default: false coroutines . set ( false ) // Enable generation of reactive response types in service methods - no default reactiveResponseType . set ( \"CompletableFuture\" ) // Add security parameters to service methods - default: false explicitSecurityParameters . set ( false ) // Set order of default media types defaultMediaTypes . set ( listOf ( \"application/json\" )) } } Tip The above examples may not show all of the options supported by the Gradle generator plugin. For a detailed list of options see check the following documentation pages Options for All Targets , Options for Kotlin Targets , Options for the Kotlin/Sunday Target , and Options for the Kotlin/JAX-RS Target","title":"Overview"},{"location":"generator/#sunday-generator-outfoxxsunday-generator","text":"The Sunday Generator is a Kotlin / Java based code generator that generates client APIs targeted for Sunday implementations in a number of languages as well as Kotlin / JAX-RS clients & servers from RAML API definitions.","title":"Sunday GENERATOR outfoxx/sunday-generator "},{"location":"generator/#supported-languages-frameworks","text":"Language Client Frameworks Server Frameworks Kotlin (JVM) Sunday , JAX-RS JAX-RS Swift Sunday TypeScript / JavaScript Sunday","title":"Supported Languages &amp; Frameworks"},{"location":"generator/#executing-sunday-generator","text":"The generator has multiple ways it can be executed to make it easily accessible in many build environments. CLI Build Plugins","title":"Executing Sunday Generator"},{"location":"generator/#cli","text":"The generator has a complete command line interface that allows generating code for any target. Being written in Kotlin the generator is first delivered as an executable UberJar (a single jar with all dependencies). Additionally, the CLI can be executed as a docker container for environments wheere docker is avaiable and Java is not already available. Executable JAR Docker java -jar cli-all-1.1.0-beta.2.jar <target> <options> docker run outfoxx/sunday-generator:1.1.0-beta.2 <target> <options>","title":"CLI"},{"location":"generator/#targets-options","text":"Each available target has a specific set of allowed options which are detailed in the following table. Kotlin / Sunday Kotlin / JAX-RS Swift / Sunday TypeScript / Sunday Generates clients targeting the Kotlin language and the Sunday library. Target kotlin/sunday Options -out PATH required Output directory. -pkg <package-name> required Default package name. -model-pkg <package-name> Default model package name. If not specified '-pkg' is used. -service-pkg <package-name> Default service package. If not specified '-pkg' is used. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -disable Disables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings Generates clients or server stubs targeting the Kotlin language and the JAX-RS library. Target kotlin/jaxrs Options -out PATH required Output directory. -mode [client|server] required Target 'client' or 'server' for generated services. -pkg <package-name> required Default package name. -model-pkg <package-name> Default model package name. If not specified '-pkg' is used. -service-pkg <package-name> Default service package. If not specified '-pkg' is used. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -disable Disables the given type generation option. Available Options: implement-model validation-constraints jackson-annotations add-generated-annotation suppress-public-api-warnings -coroutines Generate suspendable service methods for coroutine support. -reactive <type-name> Generic result type for reactive service. Specifying this option also enables the generation of reactive service methods. -explicit-security-parameters Include explicit security parameters in service methods. Generates clients targeting the Swift language and the Sunday library. Target swift/sunday Options -out PATH required Output directory. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: add-generated-annotation -disable Disables the given type generation option. Available Options: add-generated-annotation Generates clients targeting the TypeScript language and the Sunday library. Target typescript/sunday Options -out PATH required Output directory. -service-suffix <suffix> Suffix for generated services. The suffix to append to generated service types. Defaults to API . -media-type <media-type> Specifies the order of default media types. This option can be given multiple times and the order given is the order of the default media-types. -category [Service|Model] Add category of type to output. This optiona can be given multiple times to add different output categories. Defaults to all types. -problem-base <URI> Default problem base URI. -enable Enables the given type generation option. Available Options: jackson-decorators add-generated-annotation -disable Disables the given type generation option. Available Options: jackson-decorators add-generated-annotation","title":"Targets / Options"},{"location":"generator/#build-plugins","text":"In addition to the CLI, the genrator is delivered as build plugins for the following build tools:","title":"Build Plugins"},{"location":"generator/#gradle","text":"The Gradle plugin provides easy access for generating clients & server stubs for Kotlin/Java targets. The plugin allow you to create multiple \"generations\" each with their distinct sets of options to allow generating all of your code in a single project. Note Tht Gradle plugin only supports generating Kotlin & Java targets. Groovy DSL Kotlin DSL plugins { id \"io.outfoxx.sunday-generator\" version \"1.1.0-beta.2\" } sundayGenerations { // Create a generation named \"api\" api { // Input RAML files - default: \"src/main/raml/*.raml\" source = file ( \"src/main/raml/api.raml\" ) // Other RAML files dependencies - no default includes = fileTree ( \"src/main/raml\" ) // Output directory - default: \"generated/sources/sunday/<generation-name>\" outputDir = \"generated\" // TargetFramework.JAXRS or TargetFramework.Sunday - no default framework = TargetFramework . JAXRS // GenerationMode.Client or GenerationMode.Server - no default mode = GenerationMode . Client // Enable generation of model types - default: true generateModel = true // Enable generation of service types - default: true generateService = true // Default package name for model & service types - no default pkgName = \"com.example.api\" // Default package name for model types - no default modelPkgName = \"com.example.api.model\" // Default package name for service types - no default servicePkgName = \"com.example.api.services\" // Suffix to append to generated clients - default: \"API\" serviceSuffix = \"Client\" // Disable generation of bean validation annotations - default: true disableValidationConstraints = false // Disable generation of Jackson annotations - default: true disableJacksonAnnotations = false // Disable generation of model implementations - default: true disableModelImplementations = false // Enable generation of coroutines support in service methods - default: false coroutines = false // Enable generation of reactive response types in service methods - no default reactiveResponseType = \"CompletableFuture\" // Add security parameters to service methods - default: false explicitSecurityParameters = false // Set order of default media types defaultMediaTypes = listOf ( \"application/json\" ) } } plugins { id ( \"io.outfoxx.sunday-generator\" ) version ( \"1.1.0-beta.2\" ) } sundayGenerations { // Create a generation named \"api\" val api by creating { // Input RAML files - default: \"src/main/raml/*.raml\" source . set ( file ( \"src/main/raml/api.raml\" )) // Other RAML files dependencies - no default includes . set ( fileTree ( \"src/main/raml\" )) // Output directory - default: \"generated/sources/sunday/<generation-name>\" outputDir . set ( \"generated\" ) // TargetFramework.JAXRS or TargetFramework.Sunday - no default framework . set ( TargetFramework . JAXRS ) // GenerationMode.Client or GenerationMode.Server - no default mode . set ( GenerationMode . Client ) // Enable generation of model types - default: true generateModel . set ( true ) // Enable generation of service types - default: true generateService . set ( true ) // Default package name for model & service types - no default pkgName . set ( \"com.example.api\" ) // Default package name for model types - no default modelPkgName . set ( \"com.example.api.model\" ) // Default package name for service types - no default servicePkgName . set ( \"com.example.api.services\" ) // Suffix to append to generated clients - default: \"API\" serviceSuffix . set ( \"Client\" ) // Disable generation of bean validation annotations - default: true disableValidationConstraints . set ( false ) // Disable generation of Jackson annotations - default: true disableJacksonAnnotations . set ( false ) // Disable generation of model implementations - default: true disableModelImplementations . set ( false ) // Enable generation of coroutines support in service methods - default: false coroutines . set ( false ) // Enable generation of reactive response types in service methods - no default reactiveResponseType . set ( \"CompletableFuture\" ) // Add security parameters to service methods - default: false explicitSecurityParameters . set ( false ) // Set order of default media types defaultMediaTypes . set ( listOf ( \"application/json\" )) } } Tip The above examples may not show all of the options supported by the Gradle generator plugin. For a detailed list of options see check the following documentation pages Options for All Targets , Options for Kotlin Targets , Options for the Kotlin/Sunday Target , and Options for the Kotlin/JAX-RS Target","title":"Gradle"},{"location":"generator/api/","text":"Generator API The Generator, CLI and Gradle Plugin have accesible APIs. If you wish to generate Sunday clients or servers from code each module has KDoc that catalogs its complete API: Generator CLI Gradle Plugin","title":"API"},{"location":"generator/api/#generator-api","text":"The Generator, CLI and Gradle Plugin have accesible APIs. If you wish to generate Sunday clients or servers from code each module has KDoc that catalogs its complete API: Generator CLI Gradle Plugin","title":"Generator API"},{"location":"generator/kotlin-jaxrs/","text":"Kotlin - JAX-RS Details the specific features of the Kotlin/JAX-RS code generation target. Generated Types Types generated for the JAX-RS target are the same as those generated for all Kotlin target (see Generated Types for Kotlin Targets ) Generated Services Services are generated as interfaces with a service method for each API endpoint. The interfaces are adorned with all of the JAX-RS and Jackson annotations required to invoke the remote services methods. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): Response } Client / Server Support The Kotlin/JAX-RS target supports generating JAX-RS compatible interfaces that can be used as client or server stubs and is controlled by the Generation Mode Option . Server Stubs In server mode, the generated JAX-RS interfaces are designed to favor supporting the full range of JAX-RS capabilities over convenience. For example, all server service methods return a javax.ws.rs.Response instead of returning the type defined in the RAML definition. This allows doing advanced tasks like adding headers to the response. Client Stubs Some JAX-RS client implementations (e.g. RESTEasy ) support generating client proxies from JAX-RS style interfaces. The Sunday generator supports this feature by tweaking the standard generated interface to be more usable in a client environment. Client mode service methods will return a type compatible with that declared in the RAML definitions. This is different from server stubs that always return javax.ws.rs.Response . Asynchronous Methods Not Supported Service methods flagged as asynchronous are generated as regular service methods in client mode. See Reactive Support for a solution to generating asynchronous methods. Server-Sent Events Service methods flagged as producing Server-Sent Events are generated with extra parameters to support producing or consuming events. Server method stubs include the extra JAX-RS parameters Sse and SseEventSink to support producing events. Example SSE Service Method Generation (Server) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : object Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( value = \"/events/{deviceId}\" ) public fun listenToEvents ( @PathParam ( \"id\" ) id : String , @Context sse : Sse , @Context sseEvents : SseEventSink ): Unit } Client method stubs return a JAX-RS SseEventSource to support consuming events. Example SSE Service Method Generation (Client) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : object Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( value = \"/events/{deviceId}\" ) public fun listenToEvents ( @PathParam ( \"id\" ) id : String ): SseEventSource } Reactive Support Reactive support is enabled by the providing the Reactive Response Type generator options. The types must be a generic type that is suported by the user's selected JAX-RS framework. The only significant change to the generated interface is that the return type is always the provided reactive repsonse type parameterized by the response type declared in the RAML definition. This applies to both server and client interfaces. Example Reactive Service Method Generation with CompletableFuture (Server) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): CompletableFuture < Response > } Example Reactive Service Method Generation with CompletableFuture (Client) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): CompletableFuture < Item > } Kotlin Coroutines Support Some JAX-RS implementations (e.g. Quarkus ) support Kotlin coroutine methods as JAX-RS resource methods. Sunday generates coroutine service methods when the Enable Coroutine Support generator option is enabled. When coroutines are enabled service methods are generated as suspendable (e.g. they include the suspend modifier). This applies to both server and client interfaces. Example Coroutine Service Method Generation (Server) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public suspend fun fetchItem ( @PathParam ( \"id\" ) id : String ): Response } Example Coroutine Service Method Generation (Client) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public suspend fun fetchItem ( @PathParam ( \"id\" ) id : String ): Item } Explicit Security Support When the Enable Explicit Security Parameters generator option is enabled any security parmeters defined in a security scheme associated with a service method are prepended to the service methods standard paraemters. This feature allows users to explicitly handle (in server stubs) or explicitly specify (in client methods) security parameters via the interface rather than via an interceptor. Explicit Security Parameters Generation (Server) RAML API Definition #%RAML 1.0 title : Test API securitySchemes : bearer : type : Pass Through describedBy : headers : Authorization : description : JWT token type : string pattern : \"Bearer [0-9a-zA-Z+/-_=]+\" securedBy : [ bearer ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @HeaderParam ( value = \"Authorization\" ) bearerAuthorization : String , @PathParam ( \"id\" ) id : String ): Response } Generator Options In addition to the options supported by all Kotlin code generations targets , this target also supports the following options: Generation Mode Choose whether the to target client or server generation. CLI Option Gradle Plugin Properties Type Allowed Values Default -mode mode string client , server None Enable Coroutine Support Generate suspendable service methods for supporting coroutines. CLI Option Gradle Plugin Properties Type Allowed Values Default -coroutines coroutines boolean true, false false Reactive Response Type Specifies the generic result type for reactive service methods. CLI Option Gradle Plugin Properties Type Allowed Values Default -reactive reactiveResponseType string Any Valid Kotlin Type None Note This option also acts as a flag that enables reactive method generation. Enable Explicit Security Parameters Includes security parameters in generated service methods. CLI Option Gradle Plugin Properties Type Allowed Values Default -explicit-security-parameters explicitSecurityParameters boolean Any Valid Kotlin Type None","title":"JAX-RS"},{"location":"generator/kotlin-jaxrs/#kotlin-jax-rs","text":"Details the specific features of the Kotlin/JAX-RS code generation target.","title":"Kotlin - JAX-RS"},{"location":"generator/kotlin-jaxrs/#generated-types","text":"Types generated for the JAX-RS target are the same as those generated for all Kotlin target (see Generated Types for Kotlin Targets )","title":"Generated Types"},{"location":"generator/kotlin-jaxrs/#generated-services","text":"Services are generated as interfaces with a service method for each API endpoint. The interfaces are adorned with all of the JAX-RS and Jackson annotations required to invoke the remote services methods. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): Response }","title":"Generated Services"},{"location":"generator/kotlin-jaxrs/#client-server-support","text":"The Kotlin/JAX-RS target supports generating JAX-RS compatible interfaces that can be used as client or server stubs and is controlled by the Generation Mode Option .","title":"Client / Server Support"},{"location":"generator/kotlin-jaxrs/#server-stubs","text":"In server mode, the generated JAX-RS interfaces are designed to favor supporting the full range of JAX-RS capabilities over convenience. For example, all server service methods return a javax.ws.rs.Response instead of returning the type defined in the RAML definition. This allows doing advanced tasks like adding headers to the response.","title":"Server Stubs"},{"location":"generator/kotlin-jaxrs/#client-stubs","text":"Some JAX-RS client implementations (e.g. RESTEasy ) support generating client proxies from JAX-RS style interfaces. The Sunday generator supports this feature by tweaking the standard generated interface to be more usable in a client environment. Client mode service methods will return a type compatible with that declared in the RAML definitions. This is different from server stubs that always return javax.ws.rs.Response . Asynchronous Methods Not Supported Service methods flagged as asynchronous are generated as regular service methods in client mode. See Reactive Support for a solution to generating asynchronous methods.","title":"Client Stubs"},{"location":"generator/kotlin-jaxrs/#server-sent-events","text":"Service methods flagged as producing Server-Sent Events are generated with extra parameters to support producing or consuming events. Server method stubs include the extra JAX-RS parameters Sse and SseEventSink to support producing events. Example SSE Service Method Generation (Server) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : object Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( value = \"/events/{deviceId}\" ) public fun listenToEvents ( @PathParam ( \"id\" ) id : String , @Context sse : Sse , @Context sseEvents : SseEventSink ): Unit } Client method stubs return a JAX-RS SseEventSource to support consuming events. Example SSE Service Method Generation (Client) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : object Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( value = \"/events/{deviceId}\" ) public fun listenToEvents ( @PathParam ( \"id\" ) id : String ): SseEventSource }","title":"Server-Sent Events"},{"location":"generator/kotlin-jaxrs/#reactive-support","text":"Reactive support is enabled by the providing the Reactive Response Type generator options. The types must be a generic type that is suported by the user's selected JAX-RS framework. The only significant change to the generated interface is that the return type is always the provided reactive repsonse type parameterized by the response type declared in the RAML definition. This applies to both server and client interfaces. Example Reactive Service Method Generation with CompletableFuture (Server) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): CompletableFuture < Response > } Example Reactive Service Method Generation with CompletableFuture (Client) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @PathParam ( \"id\" ) id : String ): CompletableFuture < Item > }","title":"Reactive Support"},{"location":"generator/kotlin-jaxrs/#kotlin-coroutines-support","text":"Some JAX-RS implementations (e.g. Quarkus ) support Kotlin coroutine methods as JAX-RS resource methods. Sunday generates coroutine service methods when the Enable Coroutine Support generator option is enabled. When coroutines are enabled service methods are generated as suspendable (e.g. they include the suspend modifier). This applies to both server and client interfaces. Example Coroutine Service Method Generation (Server) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public suspend fun fetchItem ( @PathParam ( \"id\" ) id : String ): Response } Example Coroutine Service Method Generation (Client) RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public suspend fun fetchItem ( @PathParam ( \"id\" ) id : String ): Item }","title":"Kotlin Coroutines Support"},{"location":"generator/kotlin-jaxrs/#explicit-security-support","text":"When the Enable Explicit Security Parameters generator option is enabled any security parmeters defined in a security scheme associated with a service method are prepended to the service methods standard paraemters. This feature allows users to explicitly handle (in server stubs) or explicitly specify (in client methods) security parameters via the interface rather than via an interceptor. Explicit Security Parameters Generation (Server) RAML API Definition #%RAML 1.0 title : Test API securitySchemes : bearer : type : Pass Through describedBy : headers : Authorization : description : JWT token type : string pattern : \"Bearer [0-9a-zA-Z+/-_=]+\" securedBy : [ bearer ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Interface @Produces ( value = [ \"application/json\" ] ) @Consumes ( value = [ \"application/json\" ] ) public interface API { @GET @Path ( \"items/{id}\" ) public fun fetchItem ( @HeaderParam ( value = \"Authorization\" ) bearerAuthorization : String , @PathParam ( \"id\" ) id : String ): Response }","title":"Explicit Security Support"},{"location":"generator/kotlin-jaxrs/#generator-options","text":"In addition to the options supported by all Kotlin code generations targets , this target also supports the following options: Generation Mode Choose whether the to target client or server generation. CLI Option Gradle Plugin Properties Type Allowed Values Default -mode mode string client , server None Enable Coroutine Support Generate suspendable service methods for supporting coroutines. CLI Option Gradle Plugin Properties Type Allowed Values Default -coroutines coroutines boolean true, false false Reactive Response Type Specifies the generic result type for reactive service methods. CLI Option Gradle Plugin Properties Type Allowed Values Default -reactive reactiveResponseType string Any Valid Kotlin Type None Note This option also acts as a flag that enables reactive method generation. Enable Explicit Security Parameters Includes security parameters in generated service methods. CLI Option Gradle Plugin Properties Type Allowed Values Default -explicit-security-parameters explicitSecurityParameters boolean Any Valid Kotlin Type None","title":"Generator Options"},{"location":"generator/kotlin-sunday/","text":"Kotlin - Sunday Details the specific features of the Kotlin/Sunday code generation target. Generated Types Types generated for the Sunday target are the same as those generated for all Kotlin targets (see Generated Types for Kotlin Targets ) Generated Services Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory interface dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Item = this . requestFactory . result ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) } Note Kotlin Sunday clients are generated with service methods that are suspendable (i.e. including the suspend modifier). The generation of suspendable methods requires that they be called in a coroutine context and thus Kotlin coroutine support. Server-Sent Event Methods Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events. EventSource Service methods marked with the EventSource annotation are generated returning an EventSource . Sunday's EventSource is a work-alike to the EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API ( val requestFactory : RequestFactory , val defaultContentTypes : List < MediaType > = listOf (), val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun listenToEvents ( deviceId : String ): EventSource = this . requestFactory . eventSource ( method = Method . Get , pathTemplate = \"/events/{deviceId}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = [ MediaType . EventStream ] ) } EventStream Service methods marked with the EventStream annotation return a Kotlin Flow<T> that is parameterized to the type of event(s) the method produces. Learn about Kotlin coroutines Flow Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class class API ( val requestFactory : RequestFactory , val defaultContentTypes : List < MediaType > = listOf (), val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { fun listenToEvents ( deviceId : String ): Flow < Event > = this . requestFactory . eventStream ( method = Method . Get , pathTemplate = \"/events/{deviceId}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = [ MediaType . EventStream ] ) } Request/Response Only Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (Kotlin) library are okhttp3.Request instances and platform responses are okhttp3.Response ; this is due to the library being built upon okhttp . Request Only Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Request = this . requestFactory . request ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) } Response Only Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Response = this . requestFactory . response ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) } Default Media Types The constructors of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses. Request Encoding with Content Types Each client service constructor includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = API ( requestFactory , defaultContentTypes = listOf ( MediaType . JSON , MediaType . CBOR )) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = API ( requestFactory , defaultContentTypes = listOf ( MediaType . CBOR , MediaType . JSON )) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used. Response Encoding with Accept Types Sunday will include an Accept header equivalent, in elements and order, to that provided in the service constructor's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = API ( requestFactory , defaultAcceptTypes = listOf ( MediaType . CBOR , MediaType . JSON )) Generator Options In addition to the options supported by all Kotlin code generations targets , this target also supports the following options: None","title":"Sunday"},{"location":"generator/kotlin-sunday/#kotlin-sunday","text":"Details the specific features of the Kotlin/Sunday code generation target.","title":"Kotlin - Sunday"},{"location":"generator/kotlin-sunday/#generated-types","text":"Types generated for the Sunday target are the same as those generated for all Kotlin targets (see Generated Types for Kotlin Targets )","title":"Generated Types"},{"location":"generator/kotlin-sunday/#generated-services","text":"Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory interface dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Item = this . requestFactory . result ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) } Note Kotlin Sunday clients are generated with service methods that are suspendable (i.e. including the suspend modifier). The generation of suspendable methods requires that they be called in a coroutine context and thus Kotlin coroutine support.","title":"Generated Services"},{"location":"generator/kotlin-sunday/#server-sent-event-methods","text":"Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events.","title":"Server-Sent Event Methods"},{"location":"generator/kotlin-sunday/#eventsource","text":"Service methods marked with the EventSource annotation are generated returning an EventSource . Sunday's EventSource is a work-alike to the EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API ( val requestFactory : RequestFactory , val defaultContentTypes : List < MediaType > = listOf (), val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun listenToEvents ( deviceId : String ): EventSource = this . requestFactory . eventSource ( method = Method . Get , pathTemplate = \"/events/{deviceId}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = [ MediaType . EventStream ] ) }","title":"EventSource"},{"location":"generator/kotlin-sunday/#eventstream","text":"Service methods marked with the EventStream annotation return a Kotlin Flow<T> that is parameterized to the type of event(s) the method produces. Learn about Kotlin coroutines Flow Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class class API ( val requestFactory : RequestFactory , val defaultContentTypes : List < MediaType > = listOf (), val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { fun listenToEvents ( deviceId : String ): Flow < Event > = this . requestFactory . eventStream ( method = Method . Get , pathTemplate = \"/events/{deviceId}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = [ MediaType . EventStream ] ) }","title":"EventStream"},{"location":"generator/kotlin-sunday/#requestresponse-only","text":"Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (Kotlin) library are okhttp3.Request instances and platform responses are okhttp3.Response ; this is due to the library being built upon okhttp .","title":"Request/Response Only"},{"location":"generator/kotlin-sunday/#request-only","text":"Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Request = this . requestFactory . request ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) }","title":"Request Only"},{"location":"generator/kotlin-sunday/#response-only","text":"Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class public class API ( public val requestFactory : RequestFactory , public val defaultContentTypes : List < MediaType > = listOf (), public val defaultAcceptTypes : List < MediaType > = listOf ( MediaType . JSON ) ) { public suspend fun fetchItem ( id : String ): Response = this . requestFactory . response ( method = Method . Get , pathTemplate = \"/items/{id}\" , pathParameters = mapOf ( \"id\" to id ) acceptTypes = this . defaultAcceptTypes ) }","title":"Response Only"},{"location":"generator/kotlin-sunday/#default-media-types","text":"The constructors of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses.","title":"Default Media Types"},{"location":"generator/kotlin-sunday/#request-encoding-with-content-types","text":"Each client service constructor includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = API ( requestFactory , defaultContentTypes = listOf ( MediaType . JSON , MediaType . CBOR )) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = API ( requestFactory , defaultContentTypes = listOf ( MediaType . CBOR , MediaType . JSON )) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used.","title":"Request Encoding with Content Types"},{"location":"generator/kotlin-sunday/#response-encoding-with-accept-types","text":"Sunday will include an Accept header equivalent, in elements and order, to that provided in the service constructor's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = API ( requestFactory , defaultAcceptTypes = listOf ( MediaType . CBOR , MediaType . JSON ))","title":"Response Encoding with Accept Types"},{"location":"generator/kotlin-sunday/#generator-options","text":"In addition to the options supported by all Kotlin code generations targets , this target also supports the following options: None","title":"Generator Options"},{"location":"generator/raml-extensions/","text":"RAML Extensions The Sunday Generator defines numerous RAML extension annotations to control code generation. Annotation Definitions RAML requires that annotations be defined before that can be used. Sunday provides a RAML library with all of the extension annotations. The latest Sunday extension definition library is always available at: https://outfoxx.github.io/sunday-generator/sunday.raml To use a specific version of the Sunday extension definition library, include the verision in the URL like the following: https://outfoxx.github.io/sunday-generator/1.0.0/sunday.raml Usage of Sunday Definitions Library Any RAML file that wishes to reference the Sunday definitions must include a uses reference to the library file and prefix all references to Sunday annotations. #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml 1\ufe0f\u20e3 /test : get : (sunday.asynchronous) : true 2\ufe0f\u20e3 response : 200 : body : object Import the Sunday definitions library. This example uses the name sunday but you are free to choose any name. Prefix all references to Sunday's annotations using the chosen import name. Extensions Reference A complete reference of the defined annotation extensions is provided below. RAML Examples In an effort to be succinct, the RAML examples provided in this reference are not always complete and may forego some of the required RAML properties that API definitions require. General Annotations Annotations shared by all code generation targets. Service Group Marks resources as belonging to a named group. Annotation Type Modifiers Targets group string None Resource Allows grouping specific resources (aka endpoints) by name. A distinct service is generated for each named group and then another service is generated for the default unnamed group. Example The following RAML would create three service interfaces or classes. One for each named group (e.g. AccountAPI and AdminAPI ) as well as one for the unnamed group (e.g. API ). % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml /auth : post : displayName : login /devices : (sunday.group) : account get : displayName : listDevices /tenants : (sunday.group) : admin get : displayName : listTenants Nested Type Requests that a type be nested inside another type. Annotation Type Modifiers Targets nested Nested None Type Generates the type nested into another specified type with an explicitly specified name. Attention This annotation is ignored for any language that does not support nested types. Example Generate an enum Kind inside the type Device % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Device : properties : kind : Device-Kind name : string Device-Kind : (nested) : enclosedIn : Device name : Kind type : string enum : [ phone , tablet ] Results in the following generated code examples Kotlin Swift public class Device ( val kind : Kind , val name : String , ) { public enum class Kind { Phone , Tablet } } public class Device { public enum Kind : String { case phone = \"phone\" case tablet = \"tablet\" } public let kind : Kind public let name : String public init ( kind : Kind , name : String ) { self . kind = kind self . name = name } } Patchable Type Flag Flags a type as patchable. Annotation Type Modifiers Targets patchable boolean None Type A type flagged as patchable has special support for PATCH operations. When used in a PATCH method, a nested Patch type is generated that supports simple JSON patch/merge style updates. Example Generate Update type with patch support. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Update : type : object (sunday.patchable) : true properties : string : string int : integer bool : boolean Results in the following generated code examples Kotlin Swift public class Update ( public val string : String , public val int : Int , public val bool : Boolean ) { public fun patch ( source : ObjectNode ): Patch = Patch ( if ( source . has ( \"string\" )) Optional . ofNullable ( string ) else null , if ( source . has ( \"int\" )) Optional . ofNullable ( int ) else null , if ( source . has ( \"bool\" )) Optional . ofNullable ( bool ) else null ) @JsonInclude ( JsonInclude . Include . NON_NULL ) public data class Patch ( public val string : Optional < String >? = null , public val int : Optional < Int >? = null , public val bool : Optional < Boolean >? = null ) } public class Update { public let string : String public let int : Int public let bool : Bool public init ( string : String , int : Int , bool : Bool ) { self . string = string self . int = int self . bool = bool } func patch ( source : [ String : Any ]) -> Patch { return Patch ( string : source . keys . contains ( \"string\" ) ? Optional . some ( string ) : nil , int : source . keys . contains ( \"int\" ) ? Optional . some ( int ) : nil , bool : source . keys . contains ( \"bool\" ) ? Optional . some ( bool ) : nil ) } public struct Patch { let string : String ? let int : Int ? let bool : Bool ? init ( string : String ?, int : Int ?, bool : Bool ? ) { self . string = string self . int = int self . bool = bool } } } Polymorphic Annotations Annotations for generating polymorphic encoding/decoding of types. External Discriminator Property Name Specifies external property to be used as discriminator. Annotation Type Modifiers Targets externalDiscriminator string None Type Specifies the property name of a discriminator property in the owning object that discriminators the type flagged as externally discriminated. Note This annotation must be used in conjuction with Externally Discriminated Type Flag Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Parent : type : object discriminator : type (sunday.externallyDiscriminated) : true properties : type : string Child1 : type : Parent properties : value? : string Child2 : type : Parent discriminatorValue : child2 properties : value? : string Test : type : object properties : value : type : Parent (sunday.externalDiscriminator) : objectType objectType : string This allows implementation of the standard JSON structure: { \"objectType\" : \"child2\" , \"object\" : { \"value\" : \"test\" } } Externally Discriminated Type Flag Flags a type hierarchy as discriminated by an external property. Annotation Type Modifiers Targets externallyDiscriminated boolean None Type Polymorphic types that are marked as externally discriminated are allowed to be used as the type of another object's properties where the discriminator is also located in the other object's propereties. Note This annotation must be used in conjuction with External Discriminator Property Name Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Parent : type : object discriminator : type (sunday.externallyDiscriminated) : true properties : type : string Child1 : type : Parent properties : value? : string Child2 : type : Parent discriminatorValue : child2 properties : value? : string Test : type : object properties : parent : type : Parent (sunday.externalDiscriminator) : parentType parentType : string This allows implementation of the standard JSON structure: { \"objectType\" : \"child2\" , \"object\" : { \"value\" : \"test\" } } Problem Annotations Annotations for declaring and referencing Problem definitions. Problem Base Type URI Specifies the base URI for Problem types Annotation Type Modifiers Targets problemBaseUri string None API, Overlay Problem declarations include a requried type property that must be a URI. Sunday's succint declaration method generates the full type property value by resolving it against the base URI specified with this annotation. Any variables defined in the URI are resolved from the problemUriParams values. Relative URIs If a relative URI value is specified for problemBaseUri , it is first resolved against the API's baseUri . Fallback If this annotation is not specified the baseUri & baseUriParameters defined for the API are used instead. Problem Base Type URI Parameters Specifies parameter values for the base URI for Problem types Annotation Type Modifiers Targets problemUriParams object None API, Overlay Values for resolving resolving parameters specified in the problemBaseUri annotation. This annotation works similarly to the way baseUriParameters works for baseUri . Note If this annotation is not specified the baseUriParameters defined for the API is used instead. Problem Declarations Declare a set of reusable problems Annotation Type Modifiers Targets problemTypes ResponseProblemTypes None API, Extension, Library, Overlay Declares global problem types to be used throughout the API. The value of this annotation is a map of problem type ids to problem type details. Problem Declaration % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.problemTypes) : id_in_use : status : 400 title : ID Already In Use detail : The provided ID is already being used. custom : 1\ufe0f\u20e3 suggestedAlternative : string 2\ufe0f\u20e3 Custom properties can be specified to provide context specific details Each custom property is a the property name as the key and the type as the value Type URI Problem details require a type property that must be a URI. Sunday generates the a valid type URI by resolving the type id ( id_in_use in the example above) against the problemBaseUri if it's specified. If problemBaseUri is not specified then baseUri is used instead. Problems References Add referenced problems to methdod responses Annotation Type Modifiers Method problems ResponseProblemCodes None Method Adds each referenced problem to the range of responses the method is able to generate. Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.problemTypes) : device_not_found : 1\ufe0f\u20e3 status : 404 title : Device Not Found detail : The requested device could not be found. /devices/{id} : get : displayName : fetchDevice responses : 200 : body : Device (sunday.problems) : [ device_not_found ] 2\ufe0f\u20e3 Problems are declared via problemTypes Problems are referenced via problems Kotlin Annotations Annotations for Kotlin code generation. Kotlin Package Name Specifies default package name for generated model types and services. Annotation Type Modifiers Targets kotlinPackage string client , server API, Extension, Library, Overlay, Type Specifies the default package name that Kotlin model types and service types are generated into. When more specific package name annotations are not provided (e.g kotlinModelPackage ) the package name specified by this annotation is used. Modifiers Two modifiers are supported for targeting only client or server generation. kokotlinPackage:client Specifies the default package name when generating clients. kokotlinPackage:server Specifies the default package name when generating servers. Fallback When a kotlinPackage:client or kotlinPackage:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinPackage annotation. Examples Default Client Server Fallback Generate types and services into the com.example package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example Generate client types and services into the com.example.client package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage:client) : com.example.client Generate server types and services into the com.example.server package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage:server) : com.example.server Generate server types and services into the com.example.server package and generate client types and services into the com.example package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example (sunday.kotlinPackage:server) : com.example.server Kotlin Model Package Name Specifies default package name for generated model types. Annotation Type Modifiers Targets kotlinModelPackage string client , server API, Extension, Library, Overlay, Type Specifies the default package name that Kotlin model types are generated into. When this annotation is not specified the value of kotlinPackage is used, if specified. Modifiers Two modifiers are supported for targeting only client or server generation. kotlinModelPackage:client Specifies the default package name when generating clients. kotlinModelPackage:server Specifies the default package name when generating servers. Fallback When a kotlinModelPackage:client or kotlinModelPackage:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinModelPackage annotation. Examples Default Client Server Fallback Mixed Fallback Generate model types into the com.example.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage) : com.example.model Generate client model types into the com.example.client.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage:client) : com.example.client.model Generate server model types into the com.example.server.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage:server) : com.example.server.model Generate server model types into the com.example.server.model package and generate client model types into the com.example.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage) : com.example.model (sunday.kotlinModelPackage:server) : com.example.server.model Generate server model types into the com.example.server.model package and generate client model and service types into the com.example package using both kotlinModelPackage and kotlinPackage annotations. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example (sunday.kotlinModelPackage:server) : com.example.server.model Kotlin Type Override Specifies existing type name. Annotation Type Modifiers Targets kotlinType string client , server Type Specifies the existing type name that should be used for the annotated type. Fallback When a kotlinType:client or kotlinType:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinType annotation. Examples Default Client Server Fallback Use the standard java.net.URI type for the RAML type defined as URI % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating clients. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType:client) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType:server) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating clients and use the standard java.net.URL when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType) : java.net.URI (sunday.kotlinType:server) : java.net.URL Kotlin Implementation Code Specifies code implementing a computed property. Annotation Type Modifiers Targets kotlinImplementation TypeImplementation client , server Property Specifies Kotlin code that implements a computed class property. Fallback When a kotlinImplementation:client or kotlinImplementation:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinImplementation annotation. Examples Default Client Server Fallback Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating clients. When generating servers a standard property will be generated. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation:client) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating servers. When generating clients a standard property will be generated. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation:server) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating clients. Use the mathematic pow function when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation) : code : x.pow(2) (sunday.kotlinImplementation:client) : code : x * x TypeScript Annotations Annotations for TypeScript code generation. TypeScript Module Name Specifies default module name for generated model types and services. Annotation Type Modifiers Targets typeScriptModule string None API, Extension, Library, Overlay, Type Specifies the default module name that TypeScript model types and service types are generated into. When more specific module name annotations are not provided (e.g typeScriptModelModule ) the module name specified by this annotation is used. Example Generate model types and services into the test/example module. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModule) : test/example TypeScript Model Module Name Specifies default module name for generated model types. Annotation Type Modifiers Targets typeScriptModelModule string None API, Extension, Library, Overlay, Type Specifies the default module name that TypeScript model types are generated into. When this annotation is not specified the value of typeScriptModule is used, if specified. Example Default Mixed Generate model types into the test/example/model module. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModelModule) : test/example/model Generate model types into the test/example/model module and generate service types into the test/example module using both typeScriptModelModule and typeScriptModule annotations. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModule) : test/example (sunday.typeScriptModelModule) : test/example/model TypeScript Type Override Specifies existing type name. Annotation Type Modifiers Targets typeScriptType string None Type Specifies the existing type name that should be used for the annotated type. Example Use the standard JavaScript URL type for the RAML type defined as URL % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URL : type : string (sunday.typeScriptType) : URL TypeScript Implementation Code Specifies code implementing a computed property. Annotation Type Modifiers Targets typeScriptImplementation TypeImplementation None Property Specifies TypeScript code that implements a computed class property. Example Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.typeScriptImplementation) : code : x * x Swift Annotations Annotations for Swift code generation. Swift Type Override Specifies existing type name. Annotation Type Modifiers Targets swiftType string None Type Specifies the existing type name that should be used for the annotated type. Example Use the standard type Foundation.URL type for the RAML type defined as URL % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URL : type : string (sunday.swiftType) : Foundation.URL Swift Implementation Code Specifies code implementing a computed property. Annotation Type Modifiers Targets swiftImplementation TypeImplementation None Property Specifies Swift code that implements a computed class property. Example Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.swiftImplementation) : code : x * x Sunday Annotations Annotations for generating Sunday clients. EventSource (Server-Sent Events) Flag method as returning a raw EventSource Annotation Type Modifiers Targets eventSource boolean None Method Flags the method as returning a raw EventSource (or equivalent platform specific type). Note Any method using this annotations should also have the text/event-stream response content-type. EventStream (Server-Sent Events) Flags method as event stream and specifies the type Annotation Type Modifiers Targets eventStream EventStreamType None Method Specifies that the method should return a reactive stream of events and the method of determining what types of events the method will return. Methods The value of eventStream determines how the generator determines what type of events the method will return. The following methods are supported: discriminated The method body's type should be a RAML union of possible event types. Sunday will use each type's discriminator value to map event type names to concrete value types. If a type has not explicitly set its discriminatorValue property the RAML type name will be used. Example Generate a connectEvents service method that will produce either Opened or Closed event values. Using the discriminator of each specified type, events with the name opened will be mapped to the Opened type and events with the name closed to the Closed type. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Opened : discriminator : opened id : string Closed : discriminator : closed id : string /events : get : displayName : connectEvents (sunday.eventStream) : discriminator responses : 200 : body : (Opened | Closed) Note Any method using this annotations should also have the text/event-stream response content-type. Request Only Flag Flag method as returning a raw request value Annotation Type Modifiers Targets requestOnly boolean None Method Generates a method that does not call the remote resource endpoint. Instead the method will return a raw request value that can be used to call the resource endpoint independently. Response Only Flag Flag method as returning a raw response value Annotation Type Modifiers Targets responseOnly boolean None Method Generates a method that calls the remove resource endpoint but skips all attempts to negotiate content type and deserialize a concreate value. Instead a raw response type is returned that can be used to perform custom handling of the response. JAX-RS Annotations Annotations for generating JAX-RS client or server stub interfaces. Asynchronous Flag Flags the method as a JAX-RS asynchronous method. Annotation Type Modifiers Targets asynchronous boolean None Method Generates a JAX-RS asynchronous method. For example, in the standard implementation the generated method will have the required @Context AsyncResponse parameter added. SSE Flag Flags the method as a JAX-RS Server-Sent Events method. Annotation Type Modifiers Targets sse boolean None Method Generates a JAX-RS Server-Sent Events method. For example, in the standard implementation the generated method will have the required @Context Sse and @Context SseEventSink parameters added. Annotation Type Definitions ResponseProblemTypes: type : object properties : /^[a-z0-9_]+$/ : ResponseProblemType ResponseProblemType: type : object properties : status : type : integer minimum : 100 maximum : 599 title : type : string detail : type : string custom? : object additionalProperties : false ResponseProblemCodes: type : array items : ResponseProblemCode ResponseProblemCode: type : string pattern : '^[a-z0-9_]+$' TypeImplementation type : object properties : code : string parameters : type : array items : type : object properties : type : type : string default : Literal enum : - Type - Literal - String value : type : string Nested type : object properties : enclosedIn : string name : string EventStreamType type : string enum : [ discriminated ]","title":"Extensions"},{"location":"generator/raml-extensions/#raml-extensions","text":"The Sunday Generator defines numerous RAML extension annotations to control code generation.","title":"RAML Extensions"},{"location":"generator/raml-extensions/#annotation-definitions","text":"RAML requires that annotations be defined before that can be used. Sunday provides a RAML library with all of the extension annotations. The latest Sunday extension definition library is always available at: https://outfoxx.github.io/sunday-generator/sunday.raml To use a specific version of the Sunday extension definition library, include the verision in the URL like the following: https://outfoxx.github.io/sunday-generator/1.0.0/sunday.raml Usage of Sunday Definitions Library Any RAML file that wishes to reference the Sunday definitions must include a uses reference to the library file and prefix all references to Sunday annotations. #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml 1\ufe0f\u20e3 /test : get : (sunday.asynchronous) : true 2\ufe0f\u20e3 response : 200 : body : object Import the Sunday definitions library. This example uses the name sunday but you are free to choose any name. Prefix all references to Sunday's annotations using the chosen import name.","title":"Annotation Definitions"},{"location":"generator/raml-extensions/#extensions-reference","text":"A complete reference of the defined annotation extensions is provided below. RAML Examples In an effort to be succinct, the RAML examples provided in this reference are not always complete and may forego some of the required RAML properties that API definitions require.","title":"Extensions Reference"},{"location":"generator/raml-extensions/#general-annotations","text":"Annotations shared by all code generation targets.","title":"General Annotations"},{"location":"generator/raml-extensions/#service-group","text":"","title":"Service Group"},{"location":"generator/raml-extensions/#marks-resources-as-belonging-to-a-named-group","text":"Annotation Type Modifiers Targets group string None Resource Allows grouping specific resources (aka endpoints) by name. A distinct service is generated for each named group and then another service is generated for the default unnamed group. Example The following RAML would create three service interfaces or classes. One for each named group (e.g. AccountAPI and AdminAPI ) as well as one for the unnamed group (e.g. API ). % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml /auth : post : displayName : login /devices : (sunday.group) : account get : displayName : listDevices /tenants : (sunday.group) : admin get : displayName : listTenants","title":"Marks resources as belonging to a named group."},{"location":"generator/raml-extensions/#nested-type","text":"","title":"Nested Type"},{"location":"generator/raml-extensions/#requests-that-a-type-be-nested-inside-another-type","text":"Annotation Type Modifiers Targets nested Nested None Type Generates the type nested into another specified type with an explicitly specified name. Attention This annotation is ignored for any language that does not support nested types. Example Generate an enum Kind inside the type Device % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Device : properties : kind : Device-Kind name : string Device-Kind : (nested) : enclosedIn : Device name : Kind type : string enum : [ phone , tablet ] Results in the following generated code examples Kotlin Swift public class Device ( val kind : Kind , val name : String , ) { public enum class Kind { Phone , Tablet } } public class Device { public enum Kind : String { case phone = \"phone\" case tablet = \"tablet\" } public let kind : Kind public let name : String public init ( kind : Kind , name : String ) { self . kind = kind self . name = name } }","title":"Requests that a type be nested inside another type."},{"location":"generator/raml-extensions/#patchable-type-flag","text":"","title":"Patchable Type Flag"},{"location":"generator/raml-extensions/#flags-a-type-as-patchable","text":"Annotation Type Modifiers Targets patchable boolean None Type A type flagged as patchable has special support for PATCH operations. When used in a PATCH method, a nested Patch type is generated that supports simple JSON patch/merge style updates. Example Generate Update type with patch support. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Update : type : object (sunday.patchable) : true properties : string : string int : integer bool : boolean Results in the following generated code examples Kotlin Swift public class Update ( public val string : String , public val int : Int , public val bool : Boolean ) { public fun patch ( source : ObjectNode ): Patch = Patch ( if ( source . has ( \"string\" )) Optional . ofNullable ( string ) else null , if ( source . has ( \"int\" )) Optional . ofNullable ( int ) else null , if ( source . has ( \"bool\" )) Optional . ofNullable ( bool ) else null ) @JsonInclude ( JsonInclude . Include . NON_NULL ) public data class Patch ( public val string : Optional < String >? = null , public val int : Optional < Int >? = null , public val bool : Optional < Boolean >? = null ) } public class Update { public let string : String public let int : Int public let bool : Bool public init ( string : String , int : Int , bool : Bool ) { self . string = string self . int = int self . bool = bool } func patch ( source : [ String : Any ]) -> Patch { return Patch ( string : source . keys . contains ( \"string\" ) ? Optional . some ( string ) : nil , int : source . keys . contains ( \"int\" ) ? Optional . some ( int ) : nil , bool : source . keys . contains ( \"bool\" ) ? Optional . some ( bool ) : nil ) } public struct Patch { let string : String ? let int : Int ? let bool : Bool ? init ( string : String ?, int : Int ?, bool : Bool ? ) { self . string = string self . int = int self . bool = bool } } }","title":"Flags a type as patchable."},{"location":"generator/raml-extensions/#polymorphic-annotations","text":"Annotations for generating polymorphic encoding/decoding of types.","title":"Polymorphic Annotations"},{"location":"generator/raml-extensions/#external-discriminator-property-name","text":"","title":"External Discriminator Property Name"},{"location":"generator/raml-extensions/#specifies-external-property-to-be-used-as-discriminator","text":"Annotation Type Modifiers Targets externalDiscriminator string None Type Specifies the property name of a discriminator property in the owning object that discriminators the type flagged as externally discriminated. Note This annotation must be used in conjuction with Externally Discriminated Type Flag Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Parent : type : object discriminator : type (sunday.externallyDiscriminated) : true properties : type : string Child1 : type : Parent properties : value? : string Child2 : type : Parent discriminatorValue : child2 properties : value? : string Test : type : object properties : value : type : Parent (sunday.externalDiscriminator) : objectType objectType : string This allows implementation of the standard JSON structure: { \"objectType\" : \"child2\" , \"object\" : { \"value\" : \"test\" } }","title":"Specifies external property to be used as discriminator."},{"location":"generator/raml-extensions/#externally-discriminated-type-flag","text":"","title":"Externally Discriminated Type Flag"},{"location":"generator/raml-extensions/#flags-a-type-hierarchy-as-discriminated-by-an-external-property","text":"Annotation Type Modifiers Targets externallyDiscriminated boolean None Type Polymorphic types that are marked as externally discriminated are allowed to be used as the type of another object's properties where the discriminator is also located in the other object's propereties. Note This annotation must be used in conjuction with External Discriminator Property Name Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Parent : type : object discriminator : type (sunday.externallyDiscriminated) : true properties : type : string Child1 : type : Parent properties : value? : string Child2 : type : Parent discriminatorValue : child2 properties : value? : string Test : type : object properties : parent : type : Parent (sunday.externalDiscriminator) : parentType parentType : string This allows implementation of the standard JSON structure: { \"objectType\" : \"child2\" , \"object\" : { \"value\" : \"test\" } }","title":"Flags a type hierarchy as discriminated by an external property."},{"location":"generator/raml-extensions/#problem-annotations","text":"Annotations for declaring and referencing Problem definitions.","title":"Problem Annotations"},{"location":"generator/raml-extensions/#problem-base-type-uri","text":"","title":"Problem Base Type URI"},{"location":"generator/raml-extensions/#specifies-the-base-uri-for-problem-types","text":"Annotation Type Modifiers Targets problemBaseUri string None API, Overlay Problem declarations include a requried type property that must be a URI. Sunday's succint declaration method generates the full type property value by resolving it against the base URI specified with this annotation. Any variables defined in the URI are resolved from the problemUriParams values.","title":"Specifies the base URI for Problem types"},{"location":"generator/raml-extensions/#relative-uris","text":"If a relative URI value is specified for problemBaseUri , it is first resolved against the API's baseUri . Fallback If this annotation is not specified the baseUri & baseUriParameters defined for the API are used instead.","title":"Relative URIs"},{"location":"generator/raml-extensions/#problem-base-type-uri-parameters","text":"","title":"Problem Base Type URI Parameters"},{"location":"generator/raml-extensions/#specifies-parameter-values-for-the-base-uri-for-problem-types","text":"Annotation Type Modifiers Targets problemUriParams object None API, Overlay Values for resolving resolving parameters specified in the problemBaseUri annotation. This annotation works similarly to the way baseUriParameters works for baseUri . Note If this annotation is not specified the baseUriParameters defined for the API is used instead.","title":"Specifies parameter values for the base URI for Problem types"},{"location":"generator/raml-extensions/#problem-declarations","text":"","title":"Problem Declarations"},{"location":"generator/raml-extensions/#declare-a-set-of-reusable-problems","text":"Annotation Type Modifiers Targets problemTypes ResponseProblemTypes None API, Extension, Library, Overlay Declares global problem types to be used throughout the API. The value of this annotation is a map of problem type ids to problem type details. Problem Declaration % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.problemTypes) : id_in_use : status : 400 title : ID Already In Use detail : The provided ID is already being used. custom : 1\ufe0f\u20e3 suggestedAlternative : string 2\ufe0f\u20e3 Custom properties can be specified to provide context specific details Each custom property is a the property name as the key and the type as the value","title":"Declare a set of reusable problems"},{"location":"generator/raml-extensions/#type-uri","text":"Problem details require a type property that must be a URI. Sunday generates the a valid type URI by resolving the type id ( id_in_use in the example above) against the problemBaseUri if it's specified. If problemBaseUri is not specified then baseUri is used instead.","title":"Type URI"},{"location":"generator/raml-extensions/#problems-references","text":"","title":"Problems References"},{"location":"generator/raml-extensions/#add-referenced-problems-to-methdod-responses","text":"Annotation Type Modifiers Method problems ResponseProblemCodes None Method Adds each referenced problem to the range of responses the method is able to generate. Example % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.problemTypes) : device_not_found : 1\ufe0f\u20e3 status : 404 title : Device Not Found detail : The requested device could not be found. /devices/{id} : get : displayName : fetchDevice responses : 200 : body : Device (sunday.problems) : [ device_not_found ] 2\ufe0f\u20e3 Problems are declared via problemTypes Problems are referenced via problems","title":"Add referenced problems to methdod responses"},{"location":"generator/raml-extensions/#kotlin-annotations","text":"Annotations for Kotlin code generation.","title":"Kotlin Annotations"},{"location":"generator/raml-extensions/#kotlin-package-name","text":"","title":"Kotlin Package Name"},{"location":"generator/raml-extensions/#specifies-default-package-name-for-generated-model-types-and-services","text":"Annotation Type Modifiers Targets kotlinPackage string client , server API, Extension, Library, Overlay, Type Specifies the default package name that Kotlin model types and service types are generated into. When more specific package name annotations are not provided (e.g kotlinModelPackage ) the package name specified by this annotation is used.","title":"Specifies default package name for generated model types and services."},{"location":"generator/raml-extensions/#modifiers","text":"Two modifiers are supported for targeting only client or server generation. kokotlinPackage:client Specifies the default package name when generating clients. kokotlinPackage:server Specifies the default package name when generating servers. Fallback When a kotlinPackage:client or kotlinPackage:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinPackage annotation. Examples Default Client Server Fallback Generate types and services into the com.example package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example Generate client types and services into the com.example.client package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage:client) : com.example.client Generate server types and services into the com.example.server package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage:server) : com.example.server Generate server types and services into the com.example.server package and generate client types and services into the com.example package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example (sunday.kotlinPackage:server) : com.example.server","title":"Modifiers"},{"location":"generator/raml-extensions/#kotlin-model-package-name","text":"","title":"Kotlin Model Package Name"},{"location":"generator/raml-extensions/#specifies-default-package-name-for-generated-model-types","text":"Annotation Type Modifiers Targets kotlinModelPackage string client , server API, Extension, Library, Overlay, Type Specifies the default package name that Kotlin model types are generated into. When this annotation is not specified the value of kotlinPackage is used, if specified.","title":"Specifies default package name for generated model types."},{"location":"generator/raml-extensions/#modifiers_1","text":"Two modifiers are supported for targeting only client or server generation. kotlinModelPackage:client Specifies the default package name when generating clients. kotlinModelPackage:server Specifies the default package name when generating servers. Fallback When a kotlinModelPackage:client or kotlinModelPackage:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinModelPackage annotation. Examples Default Client Server Fallback Mixed Fallback Generate model types into the com.example.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage) : com.example.model Generate client model types into the com.example.client.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage:client) : com.example.client.model Generate server model types into the com.example.server.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage:server) : com.example.server.model Generate server model types into the com.example.server.model package and generate client model types into the com.example.model package. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinModelPackage) : com.example.model (sunday.kotlinModelPackage:server) : com.example.server.model Generate server model types into the com.example.server.model package and generate client model and service types into the com.example package using both kotlinModelPackage and kotlinPackage annotations. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.kotlinPackage) : com.example (sunday.kotlinModelPackage:server) : com.example.server.model","title":"Modifiers"},{"location":"generator/raml-extensions/#kotlin-type-override","text":"","title":"Kotlin Type Override"},{"location":"generator/raml-extensions/#specifies-existing-type-name","text":"Annotation Type Modifiers Targets kotlinType string client , server Type Specifies the existing type name that should be used for the annotated type. Fallback When a kotlinType:client or kotlinType:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinType annotation. Examples Default Client Server Fallback Use the standard java.net.URI type for the RAML type defined as URI % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating clients. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType:client) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType:server) : java.net.URI Use the standard java.net.URI type for the RAML type defined as URI when generating clients and use the standard java.net.URL when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URI : type : string (sunday.kotlinType) : java.net.URI (sunday.kotlinType:server) : java.net.URL","title":"Specifies existing type name."},{"location":"generator/raml-extensions/#kotlin-implementation-code","text":"","title":"Kotlin Implementation Code"},{"location":"generator/raml-extensions/#specifies-code-implementing-a-computed-property","text":"Annotation Type Modifiers Targets kotlinImplementation TypeImplementation client , server Property Specifies Kotlin code that implements a computed class property. Fallback When a kotlinImplementation:client or kotlinImplementation:server annotation is specificed and the generator is in an alternate mode, the generator falls back to using the unmodified kotlinImplementation annotation. Examples Default Client Server Fallback Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating clients. When generating servers a standard property will be generated. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation:client) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating servers. When generating clients a standard property will be generated. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation:server) : code : x * x Use standard arithmatic for implementing the computed xSquared property when generating clients. Use the mathematic pow function when generating servers. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.kotlinImplementation) : code : x.pow(2) (sunday.kotlinImplementation:client) : code : x * x","title":"Specifies code implementing a computed property."},{"location":"generator/raml-extensions/#typescript-annotations","text":"Annotations for TypeScript code generation.","title":"TypeScript Annotations"},{"location":"generator/raml-extensions/#typescript-module-name","text":"","title":"TypeScript Module Name"},{"location":"generator/raml-extensions/#specifies-default-module-name-for-generated-model-types-and-services","text":"Annotation Type Modifiers Targets typeScriptModule string None API, Extension, Library, Overlay, Type Specifies the default module name that TypeScript model types and service types are generated into. When more specific module name annotations are not provided (e.g typeScriptModelModule ) the module name specified by this annotation is used. Example Generate model types and services into the test/example module. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModule) : test/example","title":"Specifies default module name for generated model types and services."},{"location":"generator/raml-extensions/#typescript-model-module-name","text":"","title":"TypeScript Model Module Name"},{"location":"generator/raml-extensions/#specifies-default-module-name-for-generated-model-types","text":"Annotation Type Modifiers Targets typeScriptModelModule string None API, Extension, Library, Overlay, Type Specifies the default module name that TypeScript model types are generated into. When this annotation is not specified the value of typeScriptModule is used, if specified. Example Default Mixed Generate model types into the test/example/model module. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModelModule) : test/example/model Generate model types into the test/example/model module and generate service types into the test/example module using both typeScriptModelModule and typeScriptModule annotations. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml (sunday.typeScriptModule) : test/example (sunday.typeScriptModelModule) : test/example/model","title":"Specifies default module name for generated model types."},{"location":"generator/raml-extensions/#typescript-type-override","text":"","title":"TypeScript Type Override"},{"location":"generator/raml-extensions/#specifies-existing-type-name_1","text":"Annotation Type Modifiers Targets typeScriptType string None Type Specifies the existing type name that should be used for the annotated type. Example Use the standard JavaScript URL type for the RAML type defined as URL % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URL : type : string (sunday.typeScriptType) : URL","title":"Specifies existing type name."},{"location":"generator/raml-extensions/#typescript-implementation-code","text":"","title":"TypeScript Implementation Code"},{"location":"generator/raml-extensions/#specifies-code-implementing-a-computed-property_1","text":"Annotation Type Modifiers Targets typeScriptImplementation TypeImplementation None Property Specifies TypeScript code that implements a computed class property. Example Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.typeScriptImplementation) : code : x * x","title":"Specifies code implementing a computed property."},{"location":"generator/raml-extensions/#swift-annotations","text":"Annotations for Swift code generation.","title":"Swift Annotations"},{"location":"generator/raml-extensions/#swift-type-override","text":"","title":"Swift Type Override"},{"location":"generator/raml-extensions/#specifies-existing-type-name_2","text":"Annotation Type Modifiers Targets swiftType string None Type Specifies the existing type name that should be used for the annotated type. Example Use the standard type Foundation.URL type for the RAML type defined as URL % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : URL : type : string (sunday.swiftType) : Foundation.URL","title":"Specifies existing type name."},{"location":"generator/raml-extensions/#swift-implementation-code","text":"","title":"Swift Implementation Code"},{"location":"generator/raml-extensions/#specifies-code-implementing-a-computed-property_2","text":"Annotation Type Modifiers Targets swiftImplementation TypeImplementation None Property Specifies Swift code that implements a computed class property. Example Use standard arithmatic for implementing the computed xSquared property. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : MyObject : properties : x : number xSquared : type : number (sunday.swiftImplementation) : code : x * x","title":"Specifies code implementing a computed property."},{"location":"generator/raml-extensions/#sunday-annotations","text":"Annotations for generating Sunday clients.","title":"Sunday Annotations"},{"location":"generator/raml-extensions/#eventsource-server-sent-events","text":"","title":"EventSource (Server-Sent Events)"},{"location":"generator/raml-extensions/#flag-method-as-returning-a-raw-eventsource","text":"Annotation Type Modifiers Targets eventSource boolean None Method Flags the method as returning a raw EventSource (or equivalent platform specific type). Note Any method using this annotations should also have the text/event-stream response content-type.","title":"Flag method as returning a raw EventSource"},{"location":"generator/raml-extensions/#eventstream-server-sent-events","text":"","title":"EventStream (Server-Sent Events)"},{"location":"generator/raml-extensions/#flags-method-as-event-stream-and-specifies-the-type","text":"Annotation Type Modifiers Targets eventStream EventStreamType None Method Specifies that the method should return a reactive stream of events and the method of determining what types of events the method will return.","title":"Flags method as event stream and specifies the type"},{"location":"generator/raml-extensions/#methods","text":"The value of eventStream determines how the generator determines what type of events the method will return. The following methods are supported: discriminated The method body's type should be a RAML union of possible event types. Sunday will use each type's discriminator value to map event type names to concrete value types. If a type has not explicitly set its discriminatorValue property the RAML type name will be used. Example Generate a connectEvents service method that will produce either Opened or Closed event values. Using the discriminator of each specified type, events with the name opened will be mapped to the Opened type and events with the name closed to the Closed type. % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : Opened : discriminator : opened id : string Closed : discriminator : closed id : string /events : get : displayName : connectEvents (sunday.eventStream) : discriminator responses : 200 : body : (Opened | Closed) Note Any method using this annotations should also have the text/event-stream response content-type.","title":"Methods"},{"location":"generator/raml-extensions/#request-only-flag","text":"","title":"Request Only Flag"},{"location":"generator/raml-extensions/#flag-method-as-returning-a-raw-request-value","text":"Annotation Type Modifiers Targets requestOnly boolean None Method Generates a method that does not call the remote resource endpoint. Instead the method will return a raw request value that can be used to call the resource endpoint independently.","title":"Flag method as returning a raw request value"},{"location":"generator/raml-extensions/#response-only-flag","text":"","title":"Response Only Flag"},{"location":"generator/raml-extensions/#flag-method-as-returning-a-raw-response-value","text":"Annotation Type Modifiers Targets responseOnly boolean None Method Generates a method that calls the remove resource endpoint but skips all attempts to negotiate content type and deserialize a concreate value. Instead a raw response type is returned that can be used to perform custom handling of the response.","title":"Flag method as returning a raw response value"},{"location":"generator/raml-extensions/#jax-rs-annotations","text":"Annotations for generating JAX-RS client or server stub interfaces.","title":"JAX-RS Annotations"},{"location":"generator/raml-extensions/#asynchronous-flag","text":"","title":"Asynchronous Flag"},{"location":"generator/raml-extensions/#flags-the-method-as-a-jax-rs-asynchronous-method","text":"Annotation Type Modifiers Targets asynchronous boolean None Method Generates a JAX-RS asynchronous method. For example, in the standard implementation the generated method will have the required @Context AsyncResponse parameter added.","title":"Flags the method as a JAX-RS asynchronous method."},{"location":"generator/raml-extensions/#sse-flag","text":"","title":"SSE Flag"},{"location":"generator/raml-extensions/#flags-the-method-as-a-jax-rs-server-sent-events-method","text":"Annotation Type Modifiers Targets sse boolean None Method Generates a JAX-RS Server-Sent Events method. For example, in the standard implementation the generated method will have the required @Context Sse and @Context SseEventSink parameters added.","title":"Flags the method as a JAX-RS Server-Sent Events method."},{"location":"generator/raml-extensions/#annotation-type-definitions","text":"","title":"Annotation Type Definitions"},{"location":"generator/raml-extensions/#responseproblemtypes","text":"type : object properties : /^[a-z0-9_]+$/ : ResponseProblemType","title":"ResponseProblemTypes:"},{"location":"generator/raml-extensions/#responseproblemtype","text":"type : object properties : status : type : integer minimum : 100 maximum : 599 title : type : string detail : type : string custom? : object additionalProperties : false","title":"ResponseProblemType:"},{"location":"generator/raml-extensions/#responseproblemcodes","text":"type : array items : ResponseProblemCode","title":"ResponseProblemCodes:"},{"location":"generator/raml-extensions/#responseproblemcode","text":"type : string pattern : '^[a-z0-9_]+$'","title":"ResponseProblemCode:"},{"location":"generator/raml-extensions/#typeimplementation","text":"type : object properties : code : string parameters : type : array items : type : object properties : type : type : string default : Literal enum : - Type - Literal - String value : type : string","title":"TypeImplementation"},{"location":"generator/raml-extensions/#nested","text":"type : object properties : enclosedIn : string name : string","title":"Nested"},{"location":"generator/raml-extensions/#eventstreamtype","text":"type : string enum : [ discriminated ]","title":"EventStreamType"},{"location":"generator/swift-sunday/","text":"Swift - Sunday Details the specific features of the Swift/Sunday code generation target. Generated Types Types generated for the Sunday target are the same as those generated for all Swift targets (see Generated Types for Swift Targets ) Generated Services Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory protocol dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Swift/Sunday Service public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [. json ], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> RequestResultPublisher < Item > { return self . requestFactory . result ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } } Server-Sent Event Methods Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events. EventSource Service methods marked with the EventSource annotation are generated returning an EventSource . Sunday's EventSource is a work-alike to the EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func listenToEvents ( deviceId : String ) -> EventSource { return self . requestFactory . eventSource ( method : . get , pathTemplate : \"/events/{deviceId}\" , pathParameters : [ \"deviceId\" : deviceId ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : [. eventStream ], headers : nil )} } EventStream Service methods marked with the EventStream annotation return a Combine AnyPublisher<T, E> that is parameterized to the type of event(s) the method produces. Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func listenToEvents ( deviceId : String ) -> RequestEventPublisher < Event > { return self . requestFactory . eventStream ( method : . get , pathTemplate : \"/events/{deviceId}\" , pathParameters : [ \"deviceId\" : deviceId ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : [. eventStream ], headers : nil , eventTypes : [ \"phone\" : Phone . self , \"tablet\" : Tablet . self ] )} } Request/Response Only Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (Swift) library are Foundation.URL instances and platform responses are the tuple (response: HTTPURLResponse, data: Data?) . Request Only Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> AnyPublisher < URLRequest , Error > { return self . requestFactory . request ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } } Response Only Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> AnyPublisher < ( response : HTTPURLResponse , data : Data ?), Error > { return self . requestFactory . response ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } } Default Media Types The initializers of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses. Request Encoding with Content Types Each client service initializer includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = API ( requestFactory : requestFactory , defaultContentTypes : [. json , . cbor ]) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = API ( requestFactory : requestFactory , defaultContentTypes : [. cbor , . json ]) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used. Response Encoding with Accept Types Sunday will include an Accept header equivalent, in elements and order, to that provided in the service initializer's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = API ( requestFactory : requestFactory , defaultAcceptTypes : [. cbor , . json ]) Generator Options In addition to the options supported by all Swift code generations targets , this target also supports the following options: None","title":"Sunday"},{"location":"generator/swift-sunday/#swift-sunday","text":"Details the specific features of the Swift/Sunday code generation target.","title":"Swift - Sunday"},{"location":"generator/swift-sunday/#generated-types","text":"Types generated for the Sunday target are the same as those generated for all Swift targets (see Generated Types for Swift Targets )","title":"Generated Types"},{"location":"generator/swift-sunday/#generated-services","text":"Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory protocol dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated Swift/Sunday Service public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [. json ], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> RequestResultPublisher < Item > { return self . requestFactory . result ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } }","title":"Generated Services"},{"location":"generator/swift-sunday/#server-sent-event-methods","text":"Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events.","title":"Server-Sent Event Methods"},{"location":"generator/swift-sunday/#eventsource","text":"Service methods marked with the EventSource annotation are generated returning an EventSource . Sunday's EventSource is a work-alike to the EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func listenToEvents ( deviceId : String ) -> EventSource { return self . requestFactory . eventSource ( method : . get , pathTemplate : \"/events/{deviceId}\" , pathParameters : [ \"deviceId\" : deviceId ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : [. eventStream ], headers : nil )} }","title":"EventSource"},{"location":"generator/swift-sunday/#eventstream","text":"Service methods marked with the EventStream annotation return a Combine AnyPublisher<T, E> that is parameterized to the type of event(s) the method produces. Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func listenToEvents ( deviceId : String ) -> RequestEventPublisher < Event > { return self . requestFactory . eventStream ( method : . get , pathTemplate : \"/events/{deviceId}\" , pathParameters : [ \"deviceId\" : deviceId ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : [. eventStream ], headers : nil , eventTypes : [ \"phone\" : Phone . self , \"tablet\" : Tablet . self ] )} }","title":"EventStream"},{"location":"generator/swift-sunday/#requestresponse-only","text":"Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (Swift) library are Foundation.URL instances and platform responses are the tuple (response: HTTPURLResponse, data: Data?) .","title":"Request/Response Only"},{"location":"generator/swift-sunday/#request-only","text":"Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> AnyPublisher < URLRequest , Error > { return self . requestFactory . request ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } }","title":"Request Only"},{"location":"generator/swift-sunday/#response-only","text":"Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class public class API { public let requestFactory : RequestFactory public let defaultContentTypes : [ MediaType ] public let defaultAcceptTypes : [ MediaType ] public init ( requestFactory : RequestFactory , defaultContentTypes : [ MediaType ] = [], defaultAcceptTypes : [ MediaType ] = [. json ] ) { self . requestFactory = requestFactory self . defaultContentTypes = defaultContentTypes self . defaultAcceptTypes = defaultAcceptTypes } func fetchItem ( id : String ) -> AnyPublisher < ( response : HTTPURLResponse , data : Data ?), Error > { return self . requestFactory . response ( method : . get , pathTemplate : \"/items/{id}\" , pathParameters : [ \"id\" : id ], queryParameters : nil , body : nil as Empty ?, contentTypes : nil , acceptTypes : self . defaultAcceptTypes , headers : nil ) } }","title":"Response Only"},{"location":"generator/swift-sunday/#default-media-types","text":"The initializers of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses.","title":"Default Media Types"},{"location":"generator/swift-sunday/#request-encoding-with-content-types","text":"Each client service initializer includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = API ( requestFactory : requestFactory , defaultContentTypes : [. json , . cbor ]) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = API ( requestFactory : requestFactory , defaultContentTypes : [. cbor , . json ]) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used.","title":"Request Encoding with Content Types"},{"location":"generator/swift-sunday/#response-encoding-with-accept-types","text":"Sunday will include an Accept header equivalent, in elements and order, to that provided in the service initializer's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = API ( requestFactory : requestFactory , defaultAcceptTypes : [. cbor , . json ])","title":"Response Encoding with Accept Types"},{"location":"generator/swift-sunday/#generator-options","text":"In addition to the options supported by all Swift code generations targets , this target also supports the following options: None","title":"Generator Options"},{"location":"generator/target-common-features/","text":"Common Target Features The following features are supported by all code generation targets. Generator Options Output Directory Specifies the output directory for generated files. CLI Option Gradle Plugin Properties Type Default -out outputDir directory None Output Categories Selects which categories of output types are generated. CLI Option Gradle Plugin Properties Type Allowed Values Default -category generateModel , generateService flags service , model None Note The option can be specified multiple times, each enabling output of the specified category. Service Suffix Specifies the suffix appended to each generated service name. CLI Option Gradle Plugin Property Type Default -service-suffix serviceSuffix string API Default Media Type Ordering Specifies the order of default media types. CLI Option Gradle Plugin Property Type Default -media-type defaultMediaTypes strings None Note The CLI option can be specified multiple times, the order in which they are specified controls the default order of media-types. Default Problem Base URI Specifies the default base URI to use for resolving problem type URIs CLI Option Gradle Plugin Property Type Default -problem-base None string http://example.com","title":"Common Features"},{"location":"generator/target-common-features/#common-target-features","text":"The following features are supported by all code generation targets.","title":"Common Target Features"},{"location":"generator/target-common-features/#generator-options","text":"Output Directory Specifies the output directory for generated files. CLI Option Gradle Plugin Properties Type Default -out outputDir directory None Output Categories Selects which categories of output types are generated. CLI Option Gradle Plugin Properties Type Allowed Values Default -category generateModel , generateService flags service , model None Note The option can be specified multiple times, each enabling output of the specified category. Service Suffix Specifies the suffix appended to each generated service name. CLI Option Gradle Plugin Property Type Default -service-suffix serviceSuffix string API Default Media Type Ordering Specifies the order of default media types. CLI Option Gradle Plugin Property Type Default -media-type defaultMediaTypes strings None Note The CLI option can be specified multiple times, the order in which they are specified controls the default order of media-types. Default Problem Base URI Specifies the default base URI to use for resolving problem type URIs CLI Option Gradle Plugin Property Type Default -problem-base None string http://example.com","title":"Generator Options"},{"location":"generator/target-kotlin-common-features/","text":"Common Kotlin Target Features The following features are supported by all Kotlin code generation targets. Generated Types Scalars RAML built-in scalar types are mapped according to the following table. RAML Type Kotlin Type any Any boolean Boolean number / integer Numerics string String date-only java.time.LocalDate time-only java.time.LocalTime datetime-only java.time.LocalDateTime datetime java.time.OffsetDateTime file ByteArray nil Unit Numerics RAML number and integer types are mapped to one of Kotlins's numeric types based on the format facet. Format Kotlin Type int Int int8 Byte int16 Short int32 Int int64 Long long Long float Float double Double Objects For each RAML type that is an object or where the root of the inheritance tree is an object a Kotlin class or interface is generated. Model Classes When the generation of model implementations is enabled ( Implement Model Classes - Type Generation Option ) a POJO class is generated for each required type that supports copying, equals/hashcode, toString, etc. Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Kotlin Class public class Item ( public val name : String , public val value : Int , ) { public fun copy ( name : String? = null , value : Int? ? = null , ) = Test ( name ?: this . name , value ?: this . value ) public override fun hashCode (): Int { var result = 1 result = 31 * result + name . hashCode () result = 31 * result + value . hashCode () return result } public override fun equals ( other : Any? ): Boolean { if ( this === other ) return true if ( javaClass != other ?. javaClass ) return false other as Test if ( name != other . name ) return false if ( value != other . value ) return false return true } public override fun toString () = \"\" $ { '\"' } | Test ( name = '$ { '$' } name ' , | value = '$ { '$' } value \"\" $ { '\"' }. trimMargin () } Why not data classes? The generator currently does not gnerate Kotlin data classes to ensure easy support for generating type hierarchies. Similar features to those of data classes are generated for each class. Model Interfaces When the generation of model implementations is disabled ( Implement Model Classes - Type Generation Option ) interfaces are generated for each required types. Example Interface Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Kotlin Interface public interface Item { public val name : String public val value : Int } Simple Objects RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to Kotlin maps (i.e. Map<String, Any> ). They are generated inline and no type aliases are generated. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated Kotlin Class (simplified) public class Container ( public val map : Map < String , Any > ) Pattern Objects RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to Kotlin maps with the key as a string and the value as the type specified in the pattern (e.g. Map<String: Int> ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated Kotlin Class (simplified) public class Container ( public val map : Map < String , Int > ) Jackson Annotations The generator defaults to adding Jackson JSON serialization annotations to the generated classes and interfaces. This enables advanced JSON features (e.g. polymorphism, explicit naming, etc.) to be supported without editing the generated types or registering mixins. Example Jackson Annotations Generation (Explicit Names) RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : simple-name : string value : integer Generated Kotlin Class public class Item ( @JacksonProperty ( \"simple-name\" ) public val simpleName : String public val value : Int ) Example Jackson Annotations Generation (Polymorphism) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated Kotlin Classes @JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , include = JsonTypeInfo . As . EXISTING_PROPERTY , property = \"type\" ) @JsonSubTypes ( value = [ JsonSubTypes . Type ( name = \"phone\" , value = Phone :: class ), JsonSubTypes . Type ( name = \"tablet\" , value = Tablet :: class ) ] ) public abstract class Device ( public val name : String ) { public abstract val type : String } public class Phone ( name : String , public val hasGPS : Boolean , ) : Device ( name ) { val type : String get () = \"phone\" } public class Tablet ( type : String , public val isKeyboardAttached : Boolean , ) : Device () { val type : String get () = \"tablet\" } Note The generation of Jackson annotations can be disabled via the Jackson Annotations - Type Generation Option . Danger Disabling Jackson will most likely require a custom (de)serialization implementation to support the full feature set. Bean Validation Constraints The generator defaults to adding Bean Validation Constraints to validate instance data as they are serialized/deserialized. Example Validation Constraints Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : id : type : string pattern : [ a-zA-Z0-9 ] + value : type : integer minimum : 5 maximum : 10 Generated Kotlin Class public class Item ( @Pattern ( \"[a-zA-Z0-9]+\" ) public val id : String , @Min ( 5 ) @Max ( 10 ) public val value : Int , ) Note The generation of validation constraints can be disabled via the Validation Constraints - Type Generation Option Arrays RAML array types are mapped to Kotlin's List type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated Kotlin Class (simplified) public class Container ( public val items : List < String > ) Unions RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to Kotlin's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Inline union of types with a common ancestor. Generated Kotlin Class (simplified) public class Container ( public val device : Device ) Generated Problem Types For each problem defined & referenced using Sunday's problem annotations , a Kotlin Exception class is generated. Generating exceptions allows servers to throw a specific problem and clients to catch specific problems. Custom properties can be defined for problem types and they are added as simple Kotlin properties on the generated exception class. Example Problem Generation RAML Type Definition % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : (sunday.problemTypes) : invalid_id : status : 400 title : Invalid Id detail : The id contains one or more invalid characters custom : offendingId : string Generated Problem Exception Class public class InvalidIdProblem ( @JsonProperty ( value = \"offending_id\" ) public val offendingId : String , instance : URI? = null , cause : ThrowableProblem? = null ) : AbstractThrowableProblem ( TYPE_URI , \"Invalid Id\" , Status . BAD_REQUEST , \"The id contains one or more invalid characters.\" , instance , cause ) { public override fun getCause (): Exceptional? = super . cause public companion object { public const val TYPE : String = \"http://example.com/invalid_id\" public val TYPE_URI : URI = URI ( TYPE ) } } Generator Options In addition to the options supported by all code generations targets , this target also supports the following options: Default Package Name Specifies the default Kotlin package name for model types and service types. CLI Option Gradle Plugin Properties Type Default -pkg pkgName string None Default Model Package Name Specifies the default Kotlin package name for model types. CLI Option Gradle Plugin Properties Type Default -model-pkg modelPkgName string None Note If not specified the value specified in -pkg is used. Default Service Package Name Specifies the default Kotlin package name for service types. CLI Option Gradle Plugin Properties Type Default -service-pkg servicePkgName string None Note If not specified the value specified in -pkg is used. Type Generation Options Enable/Disable Kotlin type generation options. Supported Options Implement Model Classes Enables or Disables implementation of model classes Jackson Annotations Enables or Disables generation of Jackson annotations Validation Constraints Enables or Disables generation of bean validation annotations CLI Option Gradle Plugin Properties Type Default -disable implement-model disableModelImplementations boolean enabled -disable jackson-annotations disableJacksonAnnotations boolean enabled -disable validation-constraints disableValidationConstraints boolean enabled","title":"Common Features"},{"location":"generator/target-kotlin-common-features/#common-kotlin-target-features","text":"The following features are supported by all Kotlin code generation targets.","title":"Common Kotlin Target Features"},{"location":"generator/target-kotlin-common-features/#generated-types","text":"","title":"Generated Types"},{"location":"generator/target-kotlin-common-features/#scalars","text":"RAML built-in scalar types are mapped according to the following table. RAML Type Kotlin Type any Any boolean Boolean number / integer Numerics string String date-only java.time.LocalDate time-only java.time.LocalTime datetime-only java.time.LocalDateTime datetime java.time.OffsetDateTime file ByteArray nil Unit","title":"Scalars"},{"location":"generator/target-kotlin-common-features/#numerics","text":"RAML number and integer types are mapped to one of Kotlins's numeric types based on the format facet. Format Kotlin Type int Int int8 Byte int16 Short int32 Int int64 Long long Long float Float double Double","title":"Numerics"},{"location":"generator/target-kotlin-common-features/#objects","text":"For each RAML type that is an object or where the root of the inheritance tree is an object a Kotlin class or interface is generated.","title":"Objects"},{"location":"generator/target-kotlin-common-features/#model-classes","text":"When the generation of model implementations is enabled ( Implement Model Classes - Type Generation Option ) a POJO class is generated for each required type that supports copying, equals/hashcode, toString, etc. Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Kotlin Class public class Item ( public val name : String , public val value : Int , ) { public fun copy ( name : String? = null , value : Int? ? = null , ) = Test ( name ?: this . name , value ?: this . value ) public override fun hashCode (): Int { var result = 1 result = 31 * result + name . hashCode () result = 31 * result + value . hashCode () return result } public override fun equals ( other : Any? ): Boolean { if ( this === other ) return true if ( javaClass != other ?. javaClass ) return false other as Test if ( name != other . name ) return false if ( value != other . value ) return false return true } public override fun toString () = \"\" $ { '\"' } | Test ( name = '$ { '$' } name ' , | value = '$ { '$' } value \"\" $ { '\"' }. trimMargin () } Why not data classes? The generator currently does not gnerate Kotlin data classes to ensure easy support for generating type hierarchies. Similar features to those of data classes are generated for each class.","title":"Model Classes"},{"location":"generator/target-kotlin-common-features/#model-interfaces","text":"When the generation of model implementations is disabled ( Implement Model Classes - Type Generation Option ) interfaces are generated for each required types. Example Interface Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Kotlin Interface public interface Item { public val name : String public val value : Int }","title":"Model Interfaces"},{"location":"generator/target-kotlin-common-features/#simple-objects","text":"RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to Kotlin maps (i.e. Map<String, Any> ). They are generated inline and no type aliases are generated. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated Kotlin Class (simplified) public class Container ( public val map : Map < String , Any > )","title":"Simple Objects"},{"location":"generator/target-kotlin-common-features/#pattern-objects","text":"RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to Kotlin maps with the key as a string and the value as the type specified in the pattern (e.g. Map<String: Int> ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated Kotlin Class (simplified) public class Container ( public val map : Map < String , Int > )","title":"Pattern Objects"},{"location":"generator/target-kotlin-common-features/#jackson-annotations","text":"The generator defaults to adding Jackson JSON serialization annotations to the generated classes and interfaces. This enables advanced JSON features (e.g. polymorphism, explicit naming, etc.) to be supported without editing the generated types or registering mixins. Example Jackson Annotations Generation (Explicit Names) RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : simple-name : string value : integer Generated Kotlin Class public class Item ( @JacksonProperty ( \"simple-name\" ) public val simpleName : String public val value : Int ) Example Jackson Annotations Generation (Polymorphism) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated Kotlin Classes @JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , include = JsonTypeInfo . As . EXISTING_PROPERTY , property = \"type\" ) @JsonSubTypes ( value = [ JsonSubTypes . Type ( name = \"phone\" , value = Phone :: class ), JsonSubTypes . Type ( name = \"tablet\" , value = Tablet :: class ) ] ) public abstract class Device ( public val name : String ) { public abstract val type : String } public class Phone ( name : String , public val hasGPS : Boolean , ) : Device ( name ) { val type : String get () = \"phone\" } public class Tablet ( type : String , public val isKeyboardAttached : Boolean , ) : Device () { val type : String get () = \"tablet\" } Note The generation of Jackson annotations can be disabled via the Jackson Annotations - Type Generation Option . Danger Disabling Jackson will most likely require a custom (de)serialization implementation to support the full feature set.","title":"Jackson Annotations"},{"location":"generator/target-kotlin-common-features/#bean-validation-constraints","text":"The generator defaults to adding Bean Validation Constraints to validate instance data as they are serialized/deserialized. Example Validation Constraints Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : id : type : string pattern : [ a-zA-Z0-9 ] + value : type : integer minimum : 5 maximum : 10 Generated Kotlin Class public class Item ( @Pattern ( \"[a-zA-Z0-9]+\" ) public val id : String , @Min ( 5 ) @Max ( 10 ) public val value : Int , ) Note The generation of validation constraints can be disabled via the Validation Constraints - Type Generation Option","title":"Bean Validation Constraints"},{"location":"generator/target-kotlin-common-features/#arrays","text":"RAML array types are mapped to Kotlin's List type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated Kotlin Class (simplified) public class Container ( public val items : List < String > )","title":"Arrays"},{"location":"generator/target-kotlin-common-features/#unions","text":"RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to Kotlin's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Inline union of types with a common ancestor. Generated Kotlin Class (simplified) public class Container ( public val device : Device )","title":"Unions"},{"location":"generator/target-kotlin-common-features/#generated-problem-types","text":"For each problem defined & referenced using Sunday's problem annotations , a Kotlin Exception class is generated. Generating exceptions allows servers to throw a specific problem and clients to catch specific problems. Custom properties can be defined for problem types and they are added as simple Kotlin properties on the generated exception class. Example Problem Generation RAML Type Definition % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : (sunday.problemTypes) : invalid_id : status : 400 title : Invalid Id detail : The id contains one or more invalid characters custom : offendingId : string Generated Problem Exception Class public class InvalidIdProblem ( @JsonProperty ( value = \"offending_id\" ) public val offendingId : String , instance : URI? = null , cause : ThrowableProblem? = null ) : AbstractThrowableProblem ( TYPE_URI , \"Invalid Id\" , Status . BAD_REQUEST , \"The id contains one or more invalid characters.\" , instance , cause ) { public override fun getCause (): Exceptional? = super . cause public companion object { public const val TYPE : String = \"http://example.com/invalid_id\" public val TYPE_URI : URI = URI ( TYPE ) } }","title":"Generated Problem Types"},{"location":"generator/target-kotlin-common-features/#generator-options","text":"In addition to the options supported by all code generations targets , this target also supports the following options: Default Package Name Specifies the default Kotlin package name for model types and service types. CLI Option Gradle Plugin Properties Type Default -pkg pkgName string None Default Model Package Name Specifies the default Kotlin package name for model types. CLI Option Gradle Plugin Properties Type Default -model-pkg modelPkgName string None Note If not specified the value specified in -pkg is used. Default Service Package Name Specifies the default Kotlin package name for service types. CLI Option Gradle Plugin Properties Type Default -service-pkg servicePkgName string None Note If not specified the value specified in -pkg is used. Type Generation Options Enable/Disable Kotlin type generation options.","title":"Generator Options"},{"location":"generator/target-kotlin-common-features/#supported-options","text":"Implement Model Classes Enables or Disables implementation of model classes Jackson Annotations Enables or Disables generation of Jackson annotations Validation Constraints Enables or Disables generation of bean validation annotations CLI Option Gradle Plugin Properties Type Default -disable implement-model disableModelImplementations boolean enabled -disable jackson-annotations disableJacksonAnnotations boolean enabled -disable validation-constraints disableValidationConstraints boolean enabled","title":"Supported Options"},{"location":"generator/target-swift-common-features/","text":"Common Swift Target Features The following features are supported by all Swift code generation targets. Generated Types Scalars RAML built-in scalar types are mapped according to the following table. RAML Type Swift Type any Any boolean Boolean number / integer Numerics string String date-only Date time-only Date datetime-only Date datetime Date file Data nil Optional.none (aka nil ) Numerics RAML number and integer types are mapped to one of Swift's numeric types based on the format facet. Format Swift Type int Int int8 Int8 int16 Int16 int32 Int32 int64 Int64 long Int64 float Float double Double Objects For each RAML type that is an object or where the root of the inheritance tree is an object and contains any defined properties, a Swift class is generated. Generated classes are immutable and fluent modifier functions are generated for each property defined on the type. Each generated class implements Codable and CustomDebugStringConvertible . It's left up to the users to implement other Swift standard protocols like Equatable and/or Hashable . Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Swift Class public class Item : Codable , CustomDebugStringConvertible { public let name : String public let value : Int public var debugDescription : String { return DescriptionBuilder ( Test . self ) . add ( name , named : \"name\" ) . add ( value , named : \"value\" ) . build () } public init ( name : String , value : Int ) { self . name = name self . value = value } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . name = try container . decode ( String . self , forKey : . name ) self . value = try container . decode ( Int . self , forKey : . value ) } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . name , forKey : . name ) try container . encode ( self . value , forKey : . value ) } public func withName ( name : String ) -> Test { return Test ( name : name , value : value ) } public func withValue ( value : Int ) -> Test { return Test ( name : name , value : value ) } fileprivate enum CodingKeys : String , CodingKey { case name = \"name\" case value = \"value\" } } Inherited Objects RAML types that inherit from a single parent type are generated as a class hierarchy. As long as each type in the hierarchy only inherits from a single parent type the hierarch can be as complex as the author requires. When the root of the RAML hierarchy has the discriminator facet set, the generated class hierarchy will support polymorphic decoding using a nested reference object named AnyRef . Example Class Hierarchy Generation RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated Swift Classes public class Device : Codable { public var type : String { fatalError ( \"abstract type method\" ) } public let name : String public var debugDescription : String { return DescriptionBuilder ( Device . self ) . build () } public init ( name : String ) { self . name = name } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . name = try container . decode ( String . self , forKey : . name ) } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . name , forKey : . name ) } public enum AnyRef : Codable , CustomDebugStringConvertible { case phone ( Phone ) case tablet ( Tablet ) public var value : Device { switch self { case . phone ( let value ): return value case . tablet ( let value ): return value } } public var debugDescription : String { switch self { case . phone ( let value ): return value . debugDescription case . tablet ( let value ): return value . debugDescription } } public init ( value : Device ) { switch value { case let value as Phone : self = . phone ( value ) case let value as Tablet : self = . tablet ( value ) default : fatalError ( \"Invalid value type\" ) } } public init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) let type = try container . decode ( String . self , forKey : CodingKeys . type ) switch type { case \"phone\" : self = . phone ( try Phone ( from : decoder )) case \"tablet\" : self = . tablet ( try Tablet ( from : decoder )) default : throw DecodingError . dataCorruptedError ( forKey : CodingKeys . type , in : container , debugDescription : \"unsupported value for \\\" type \\\" \" ) } } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) switch self { case . phone ( let value ): try container . encode ( \"phone\" , forKey : . type ) try value . encode ( to : encoder ) case . tablet ( let value ): try container . encode ( \"tablet\" , forKey : . type ) try value . encode ( to : encoder ) } } } fileprivate enum CodingKeys : String , CodingKey { case type = \"type\" } } public class Phone : Parent { public override var type : String { return \"phone\" } public let hasGPS : Boolean public override var debugDescription : String { return DescriptionBuilder ( Phone . self ) . add ( type , named : \"type\" ) . add ( name , named : \"name\" ) . add ( hasGPS , named : \"hasGPS\" ) . build () } public init ( name : String , hasGPS : Boolean ) { self . hasGPS = hasGPS super . init ( name : name ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . hasGPS = try container . decode ( Boolean . self , forKey : . hasGPS ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . hasGPS , forKey : . hasGPS ) } public func withName ( name : String ) -> Phone { return Phone ( name : name , isKeyboardAttached : isKeyboardAttached ) } public func withHasGPS ( hasGPS : Boolean ) -> Phone { return Phone ( name : name , hasGPS : hasGPS ) } fileprivate enum CodingKeys : String , CodingKey { case hasGPS = \"hasGPS\" } } public class Tablet : Parent { public override var type : String { return \"tablet\" } public let isKeyboardAttached : Boolean public override var debugDescription : String { return DescriptionBuilder ( Tablet . self ) . add ( type , named : \"type\" ) . add ( name , named : \"name\" ) . add ( isKeyboardAttached , named : \"isKeyboardAttached\" ) . build () } public init ( name : String , isKeyboardAttached : Boolean ) { self . isKeyboardAttached = isKeyboardAttached super . init ( name : name ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . isKeyboardAttached = try container . decode ( Boolean . self , forKey : . isKeyboardAttached ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . isKeyboardAttached , forKey : . isKeyboardAttached ) } public func withName ( name : String ) -> Tablet { return Tablet ( name : name , isKeyboardAttached : isKeyboardAttached ) } public func withIsKeyboardAttached ( isKeyboardAttached : Boolean ) -> Tablet { return Tablet ( name : name , isKeyboardAttached : isKeyboardAttached ) } fileprivate enum CodingKeys : String , CodingKey { case isKeyboardAttached = \"isKeyboardAttached\" } } Use Generated AnyRef to Encode/Decode let decodedDevice = JsonDecoder (). decode ( Device . AnyRef ). value let encodedDevice = JsonEncoder (). encode ( Device . AnyRef ( decodedDevice )) Simple Objects RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to Swift dictionaries (i.e. [String: Any] ). They are generated inline and no type aliases are generated. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated Swift Class (simplified) class Container : Codable { let map : [ String : Any ] init ( items : [ String : Any ]) { self . map = map } } Pattern Objects RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to Swift dictionaries with the key as a string and the value as the type specified in the pattern (e.g. [String: Int] ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated Swift Class (simplified) class Container : Codable { let map : [ String : Int ] init ( items : [ String : Int ]) { self . map = map } } Arrays RAML array types are mapped to Swift's Array type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated Swift Class (simplified) class Container : Codable { let items : [ String ] init ( items : [ String ]) { self . items = items } } Unions RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to Swit's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Generated Swift Class (simplified) public class Container { let device : Device init ( device : Device ) { self . device = device } } Generated Problem Types For each problem defined & referenced using Sunday's Sunday's problem annotations , a Swift Error class is generated. Generating exceptions allows servers to throw a specific problem and clients to catch specific problems. Custom properties can be defined for problem types and they are added as simple Swift properties on the generated error class. Example Problem Generation RAML Type Definition % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : (sunday.problemTypes) : invalid_id : status : 400 title : Invalid Id detail : The id contains one or more invalid characters custom : offendingId : string Generated Problem Error Class public class InvalidIdProblem : Problem { public static let type : URL = URL ( string : \"http://example.com/invalid_id\" ) ! public let offendingId : String var description : String { return DescriptionBuilder ( Self . self ) . add ( type , named : \"type\" ) . add ( title , named : \"title\" ) . add ( status , named : \"status\" ) . add ( detail , named : \"detail\" ) . add ( instance , named : \"instance\" ) . add ( offendingId , named : \"offendingId\" ) . build () } init ( offendingId : String , instance : URL ? = nil ) { self . offendingId = offendingId super . init ( type : Self . type , title : \"Invalid Id\" , status : 400 , detail : \"The id contains one or more invalid characters.\" , instance : instance , parameters : nil ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . offendingId = try container . decode ( String . self , forKey : CodingKeys . offendingId ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . offendingId , forKey : CodingKeys . offendingId ) } fileprivate enum CodingKeys : String , CodingKey { case offendingId = \"offending_id\" } } Generator Options In addition to the options supported by all code generations targets , this target also supports the following options: Type Generation Options Enable/Disable Swift type generation options. Supported Options Add Generated Annotation Enables or Disables adding generation annotations to generated types CLI Option Gradle Plugin Properties Type Default -disable add-generation-annotation boolean enabled","title":"Common Features"},{"location":"generator/target-swift-common-features/#common-swift-target-features","text":"The following features are supported by all Swift code generation targets.","title":"Common Swift Target Features"},{"location":"generator/target-swift-common-features/#generated-types","text":"","title":"Generated Types"},{"location":"generator/target-swift-common-features/#scalars","text":"RAML built-in scalar types are mapped according to the following table. RAML Type Swift Type any Any boolean Boolean number / integer Numerics string String date-only Date time-only Date datetime-only Date datetime Date file Data nil Optional.none (aka nil )","title":"Scalars"},{"location":"generator/target-swift-common-features/#numerics","text":"RAML number and integer types are mapped to one of Swift's numeric types based on the format facet. Format Swift Type int Int int8 Int8 int16 Int16 int32 Int32 int64 Int64 long Int64 float Float double Double","title":"Numerics"},{"location":"generator/target-swift-common-features/#objects","text":"For each RAML type that is an object or where the root of the inheritance tree is an object and contains any defined properties, a Swift class is generated. Generated classes are immutable and fluent modifier functions are generated for each property defined on the type. Each generated class implements Codable and CustomDebugStringConvertible . It's left up to the users to implement other Swift standard protocols like Equatable and/or Hashable . Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated Swift Class public class Item : Codable , CustomDebugStringConvertible { public let name : String public let value : Int public var debugDescription : String { return DescriptionBuilder ( Test . self ) . add ( name , named : \"name\" ) . add ( value , named : \"value\" ) . build () } public init ( name : String , value : Int ) { self . name = name self . value = value } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . name = try container . decode ( String . self , forKey : . name ) self . value = try container . decode ( Int . self , forKey : . value ) } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . name , forKey : . name ) try container . encode ( self . value , forKey : . value ) } public func withName ( name : String ) -> Test { return Test ( name : name , value : value ) } public func withValue ( value : Int ) -> Test { return Test ( name : name , value : value ) } fileprivate enum CodingKeys : String , CodingKey { case name = \"name\" case value = \"value\" } }","title":"Objects"},{"location":"generator/target-swift-common-features/#inherited-objects","text":"RAML types that inherit from a single parent type are generated as a class hierarchy. As long as each type in the hierarchy only inherits from a single parent type the hierarch can be as complex as the author requires. When the root of the RAML hierarchy has the discriminator facet set, the generated class hierarchy will support polymorphic decoding using a nested reference object named AnyRef . Example Class Hierarchy Generation RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated Swift Classes public class Device : Codable { public var type : String { fatalError ( \"abstract type method\" ) } public let name : String public var debugDescription : String { return DescriptionBuilder ( Device . self ) . build () } public init ( name : String ) { self . name = name } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . name = try container . decode ( String . self , forKey : . name ) } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . name , forKey : . name ) } public enum AnyRef : Codable , CustomDebugStringConvertible { case phone ( Phone ) case tablet ( Tablet ) public var value : Device { switch self { case . phone ( let value ): return value case . tablet ( let value ): return value } } public var debugDescription : String { switch self { case . phone ( let value ): return value . debugDescription case . tablet ( let value ): return value . debugDescription } } public init ( value : Device ) { switch value { case let value as Phone : self = . phone ( value ) case let value as Tablet : self = . tablet ( value ) default : fatalError ( \"Invalid value type\" ) } } public init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) let type = try container . decode ( String . self , forKey : CodingKeys . type ) switch type { case \"phone\" : self = . phone ( try Phone ( from : decoder )) case \"tablet\" : self = . tablet ( try Tablet ( from : decoder )) default : throw DecodingError . dataCorruptedError ( forKey : CodingKeys . type , in : container , debugDescription : \"unsupported value for \\\" type \\\" \" ) } } public func encode ( to encoder : Encoder ) throws { var container = encoder . container ( keyedBy : CodingKeys . self ) switch self { case . phone ( let value ): try container . encode ( \"phone\" , forKey : . type ) try value . encode ( to : encoder ) case . tablet ( let value ): try container . encode ( \"tablet\" , forKey : . type ) try value . encode ( to : encoder ) } } } fileprivate enum CodingKeys : String , CodingKey { case type = \"type\" } } public class Phone : Parent { public override var type : String { return \"phone\" } public let hasGPS : Boolean public override var debugDescription : String { return DescriptionBuilder ( Phone . self ) . add ( type , named : \"type\" ) . add ( name , named : \"name\" ) . add ( hasGPS , named : \"hasGPS\" ) . build () } public init ( name : String , hasGPS : Boolean ) { self . hasGPS = hasGPS super . init ( name : name ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . hasGPS = try container . decode ( Boolean . self , forKey : . hasGPS ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . hasGPS , forKey : . hasGPS ) } public func withName ( name : String ) -> Phone { return Phone ( name : name , isKeyboardAttached : isKeyboardAttached ) } public func withHasGPS ( hasGPS : Boolean ) -> Phone { return Phone ( name : name , hasGPS : hasGPS ) } fileprivate enum CodingKeys : String , CodingKey { case hasGPS = \"hasGPS\" } } public class Tablet : Parent { public override var type : String { return \"tablet\" } public let isKeyboardAttached : Boolean public override var debugDescription : String { return DescriptionBuilder ( Tablet . self ) . add ( type , named : \"type\" ) . add ( name , named : \"name\" ) . add ( isKeyboardAttached , named : \"isKeyboardAttached\" ) . build () } public init ( name : String , isKeyboardAttached : Boolean ) { self . isKeyboardAttached = isKeyboardAttached super . init ( name : name ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . isKeyboardAttached = try container . decode ( Boolean . self , forKey : . isKeyboardAttached ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . isKeyboardAttached , forKey : . isKeyboardAttached ) } public func withName ( name : String ) -> Tablet { return Tablet ( name : name , isKeyboardAttached : isKeyboardAttached ) } public func withIsKeyboardAttached ( isKeyboardAttached : Boolean ) -> Tablet { return Tablet ( name : name , isKeyboardAttached : isKeyboardAttached ) } fileprivate enum CodingKeys : String , CodingKey { case isKeyboardAttached = \"isKeyboardAttached\" } } Use Generated AnyRef to Encode/Decode let decodedDevice = JsonDecoder (). decode ( Device . AnyRef ). value let encodedDevice = JsonEncoder (). encode ( Device . AnyRef ( decodedDevice ))","title":"Inherited Objects"},{"location":"generator/target-swift-common-features/#simple-objects","text":"RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to Swift dictionaries (i.e. [String: Any] ). They are generated inline and no type aliases are generated. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated Swift Class (simplified) class Container : Codable { let map : [ String : Any ] init ( items : [ String : Any ]) { self . map = map } }","title":"Simple Objects"},{"location":"generator/target-swift-common-features/#pattern-objects","text":"RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to Swift dictionaries with the key as a string and the value as the type specified in the pattern (e.g. [String: Int] ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated Swift Class (simplified) class Container : Codable { let map : [ String : Int ] init ( items : [ String : Int ]) { self . map = map } }","title":"Pattern Objects"},{"location":"generator/target-swift-common-features/#arrays","text":"RAML array types are mapped to Swift's Array type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated Swift Class (simplified) class Container : Codable { let items : [ String ] init ( items : [ String ]) { self . items = items } }","title":"Arrays"},{"location":"generator/target-swift-common-features/#unions","text":"RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to Swit's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Generated Swift Class (simplified) public class Container { let device : Device init ( device : Device ) { self . device = device } }","title":"Unions"},{"location":"generator/target-swift-common-features/#generated-problem-types","text":"For each problem defined & referenced using Sunday's Sunday's problem annotations , a Swift Error class is generated. Generating exceptions allows servers to throw a specific problem and clients to catch specific problems. Custom properties can be defined for problem types and they are added as simple Swift properties on the generated error class. Example Problem Generation RAML Type Definition % RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml types : (sunday.problemTypes) : invalid_id : status : 400 title : Invalid Id detail : The id contains one or more invalid characters custom : offendingId : string Generated Problem Error Class public class InvalidIdProblem : Problem { public static let type : URL = URL ( string : \"http://example.com/invalid_id\" ) ! public let offendingId : String var description : String { return DescriptionBuilder ( Self . self ) . add ( type , named : \"type\" ) . add ( title , named : \"title\" ) . add ( status , named : \"status\" ) . add ( detail , named : \"detail\" ) . add ( instance , named : \"instance\" ) . add ( offendingId , named : \"offendingId\" ) . build () } init ( offendingId : String , instance : URL ? = nil ) { self . offendingId = offendingId super . init ( type : Self . type , title : \"Invalid Id\" , status : 400 , detail : \"The id contains one or more invalid characters.\" , instance : instance , parameters : nil ) } public required init ( from decoder : Decoder ) throws { let container = try decoder . container ( keyedBy : CodingKeys . self ) self . offendingId = try container . decode ( String . self , forKey : CodingKeys . offendingId ) try super . init ( from : decoder ) } public override func encode ( to encoder : Encoder ) throws { try super . encode ( to : encoder ) var container = encoder . container ( keyedBy : CodingKeys . self ) try container . encode ( self . offendingId , forKey : CodingKeys . offendingId ) } fileprivate enum CodingKeys : String , CodingKey { case offendingId = \"offending_id\" } }","title":"Generated Problem Types"},{"location":"generator/target-swift-common-features/#generator-options","text":"In addition to the options supported by all code generations targets , this target also supports the following options: Type Generation Options Enable/Disable Swift type generation options.","title":"Generator Options"},{"location":"generator/target-swift-common-features/#supported-options","text":"Add Generated Annotation Enables or Disables adding generation annotations to generated types CLI Option Gradle Plugin Properties Type Default -disable add-generation-annotation boolean enabled","title":"Supported Options"},{"location":"generator/target-typescript-common-features/","text":"Common TypeScript Target Features The following features are supported by all TypeScript code generation targets. Generated Types Scalars RAML built-in scalar types are mapped according to the following table. RAML Type TypeScript Type any any boolean boolean number / integer number string string date-only LocalDate (Sunday) time-only LocalTime (Sunday) datetime-only LocalDateTime (Sunday) datetime OffsetDateTime (Sunday) file ArrayBuffer nil void Objects For each RAML type that is an object or where the root of the inheritance tree is an object and contains any defined properties, a TypeScript interface and implementing class are generated. Value constructors and fluent style copy methods are generated by default for all classes. Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated TypeScript Class export interface Item { name : string ; value : number ; } export class Item implements Item { name : string ; value : number ; constructor ( name : string , value : number ) { this . name = name ; this . value = value ; } copy ( src : Partial < Item > ) : Item { return new Item ( src . name ?? this . name , src . value ?? this . value ) } toString () { return `Item(name=' ${ this . name } ', value=' ${ this . value } ')` ; } } Simple Objects RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to the TypeScript object type. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated TypeScript Class export interface Container { map : object ; } export class Container implements Container { map : object ; constructor ( map : object ) { this . map = map ; } copy ( src : Partial < Container > ) : Container { return new Container ( src . map ?? this . map ) } toString () { return `Container(map=' ${ this . map } ')` ; } ) Pattern Objects RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to TypeScript built-in objects with the key as a string and the value as the type specified in the pattern (e.g. { [key: string]: number } ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated TypeScript Class (simplified) export interface Container { map : { [ key : string ] : number }; } export class Container implements Container { map : { [ key : string ] : number }; constructor ( map : { [ key : string ] : number }) { this . map = map ; } copy ( src : Partial < Container > ) : Container { return new Container ( src . map ?? this . map ) } toString () { return `Container(map=' ${ this . map } ')` ; } ) JacksonJS Decorators The generator defaults to adding JacksonJS JSON serialization annotations to the generated classes and interfaces. This enables advanced JSON features (e.g. polymorphism, explicit naming, etc.) to be supported without editing the generated types or registering mixins. Example JacksonJS Annotations Generation (Explicit Names) RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : simple-name : string value : integer Generated TypeScript Class export interface Item { name : string ; value : number ; } export class Item implements Item { @JsonProperty ({ value : 'simple-name' }) @JsonClassType ({ type : () => [ String ]}) name : string ; @JsonClassType ({ type : () => [ Number ]}) value : number ; constructor ( name : string , value : number ) { this . name = name ; this . value = value ; } copy ( src : Partial < Item > ) : Item { return new Item ( src . name ?? this . name , src . value ?? this . value ) } toString () { return `Item(name=' ${ this . name } ', value=' ${ this . value } ')` ; } } Example JacksonJS Annotations Generation (Polymorphism) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated TypeScript Classes export interface Device { type : string ; name : string ; } @JsonTypeInfo ({ use : JsonTypeInfo.Id.NAME , include : JsonTypeInfoAs.PROPERTY , property : 'type' }) @JsonSubTypes ({ types : [ { class : () => eval ( 'Phone' ), name : 'phone' }, { class : () => eval ( 'Tablet' ), name = \"tablet\" } ] }) export abstract class Device implements Device { name : string ; constructor ( name : string ) { this . name = name ; } toString () : string { return `Device()` ; } } export interface Phone extends Device { hasGPS : boolean ; } export class Phone extends Device implements Phone { @JsonClassType ({ type : () => [ Boolean ]}) hasGPS : boolean ; constructor ( name : string , hasGPS : boolean ) { super ( name ); this . hasGPS = hasGPS ; } get type () : string { return 'tablet' ; } copy ( src : Partial < Phone > ) : Phone { return new Phone ( src . name ?? this . name , src . hasGPS ?? this . hasGPS ); } toString () : string { return `Phone(name= ${ this . name } , hasGPS= ${ this . hasGPS } )` ; } } export interface Tablet extends Device { isKeyboardAttached : boolean ; } export class Tablet extends Device implements Tablet { @JsonClassType ({ type : () => [ Boolean ]}) isKeyboardAttached : boolean ; constructor ( name : string , isKeyboardAttached : boolean ) { super ( name ); this . isKeyboardAttached = isKeyboardAttached ; } get type () : string { return 'tablet' ; } copy ( src : Partial < Tablet > ) : Tablet { return new Tablet ( src . name ?? this . name , src . isKeyboardAttached ?? this . isKeyboardAttached ); } toString () : string { return `Tablet(name= ${ this . name } , isKeyboardAttached= ${ this . isKeyboardAttached } )` ; } } Note The generation of JacksonJS annotations can be disabled via the JacksonJS Annotations - Type Generation Option . Danger Disabling JacksonJS will most likely require a custom (de)serialization implementation to support the full feature set. Arrays RAML array types are mapped to TypeScript's Array type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated TypeScript Class (simplified) export class Container { items : Array < string > ; constructor ( items : Array < string > ) { this . items = items ; } } Unions RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to TypeScript's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Inline union of types with a common ancestor. Generated TypeScript Class (simplified) export class Container { device : Device ; constructor ( device : Device ) { this . device = device ; } } Generator Options In addition to the options supported by all code generations targets , this target also supports the following options: Type Generation Options Enable/Disable TypeScript type generation options. Supported Options JacksonJS Decorators Enables or Disables generation of JacksonJS decorators Add Generated Header Enables or Disables adding generation headers to generated types CLI Option Gradle Plugin Properties Type Default -disable jackson-decorators boolean enabled -disable add-generation-header boolean enabled","title":"Common Features"},{"location":"generator/target-typescript-common-features/#common-typescript-target-features","text":"The following features are supported by all TypeScript code generation targets.","title":"Common TypeScript Target Features"},{"location":"generator/target-typescript-common-features/#generated-types","text":"","title":"Generated Types"},{"location":"generator/target-typescript-common-features/#scalars","text":"RAML built-in scalar types are mapped according to the following table. RAML Type TypeScript Type any any boolean boolean number / integer number string string date-only LocalDate (Sunday) time-only LocalTime (Sunday) datetime-only LocalDateTime (Sunday) datetime OffsetDateTime (Sunday) file ArrayBuffer nil void","title":"Scalars"},{"location":"generator/target-typescript-common-features/#objects","text":"For each RAML type that is an object or where the root of the inheritance tree is an object and contains any defined properties, a TypeScript interface and implementing class are generated. Value constructors and fluent style copy methods are generated by default for all classes. Example Class Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : name : String value : integer Generated TypeScript Class export interface Item { name : string ; value : number ; } export class Item implements Item { name : string ; value : number ; constructor ( name : string , value : number ) { this . name = name ; this . value = value ; } copy ( src : Partial < Item > ) : Item { return new Item ( src . name ?? this . name , src . value ?? this . value ) } toString () { return `Item(name=' ${ this . name } ', value=' ${ this . value } ')` ; } }","title":"Objects"},{"location":"generator/target-typescript-common-features/#simple-objects","text":"RAML types that are \"simple\" objects (where no properties facet is defined) are mapped to the TypeScript object type. Example Simple Object Generation RAML Type Definition % RAML 1.0 title : Test API types : Container : map : object Generated TypeScript Class export interface Container { map : object ; } export class Container implements Container { map : object ; constructor ( map : object ) { this . map = map ; } copy ( src : Partial < Container > ) : Container { return new Container ( src . map ?? this . map ) } toString () { return `Container(map=' ${ this . map } ')` ; } )","title":"Simple Objects"},{"location":"generator/target-typescript-common-features/#pattern-objects","text":"RAML types that only contain pattern properties (i.e. property names defined by regular expressions) are mapped to TypeScript built-in objects with the key as a string and the value as the type specified in the pattern (e.g. { [key: string]: number } ). They are generated inline and no type aliases are generated. Example Pattern Object Generation RAML Type Definition % RAML 1.0 title : Test API types : MapOfInts : type : object // : integer Container : map : MapOfInts Generated TypeScript Class (simplified) export interface Container { map : { [ key : string ] : number }; } export class Container implements Container { map : { [ key : string ] : number }; constructor ( map : { [ key : string ] : number }) { this . map = map ; } copy ( src : Partial < Container > ) : Container { return new Container ( src . map ?? this . map ) } toString () { return `Container(map=' ${ this . map } ')` ; } )","title":"Pattern Objects"},{"location":"generator/target-typescript-common-features/#jacksonjs-decorators","text":"The generator defaults to adding JacksonJS JSON serialization annotations to the generated classes and interfaces. This enables advanced JSON features (e.g. polymorphism, explicit naming, etc.) to be supported without editing the generated types or registering mixins. Example JacksonJS Annotations Generation (Explicit Names) RAML Type Definition % RAML 1.0 title : Test API types : Item : type : object properties : simple-name : string value : integer Generated TypeScript Class export interface Item { name : string ; value : number ; } export class Item implements Item { @JsonProperty ({ value : 'simple-name' }) @JsonClassType ({ type : () => [ String ]}) name : string ; @JsonClassType ({ type : () => [ Number ]}) value : number ; constructor ( name : string , value : number ) { this . name = name ; this . value = value ; } copy ( src : Partial < Item > ) : Item { return new Item ( src . name ?? this . name , src . value ?? this . value ) } toString () { return `Item(name=' ${ this . name } ', value=' ${ this . value } ')` ; } } Example JacksonJS Annotations Generation (Polymorphism) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean Generated TypeScript Classes export interface Device { type : string ; name : string ; } @JsonTypeInfo ({ use : JsonTypeInfo.Id.NAME , include : JsonTypeInfoAs.PROPERTY , property : 'type' }) @JsonSubTypes ({ types : [ { class : () => eval ( 'Phone' ), name : 'phone' }, { class : () => eval ( 'Tablet' ), name = \"tablet\" } ] }) export abstract class Device implements Device { name : string ; constructor ( name : string ) { this . name = name ; } toString () : string { return `Device()` ; } } export interface Phone extends Device { hasGPS : boolean ; } export class Phone extends Device implements Phone { @JsonClassType ({ type : () => [ Boolean ]}) hasGPS : boolean ; constructor ( name : string , hasGPS : boolean ) { super ( name ); this . hasGPS = hasGPS ; } get type () : string { return 'tablet' ; } copy ( src : Partial < Phone > ) : Phone { return new Phone ( src . name ?? this . name , src . hasGPS ?? this . hasGPS ); } toString () : string { return `Phone(name= ${ this . name } , hasGPS= ${ this . hasGPS } )` ; } } export interface Tablet extends Device { isKeyboardAttached : boolean ; } export class Tablet extends Device implements Tablet { @JsonClassType ({ type : () => [ Boolean ]}) isKeyboardAttached : boolean ; constructor ( name : string , isKeyboardAttached : boolean ) { super ( name ); this . isKeyboardAttached = isKeyboardAttached ; } get type () : string { return 'tablet' ; } copy ( src : Partial < Tablet > ) : Tablet { return new Tablet ( src . name ?? this . name , src . isKeyboardAttached ?? this . isKeyboardAttached ); } toString () : string { return `Tablet(name= ${ this . name } , isKeyboardAttached= ${ this . isKeyboardAttached } )` ; } } Note The generation of JacksonJS annotations can be disabled via the JacksonJS Annotations - Type Generation Option . Danger Disabling JacksonJS will most likely require a custom (de)serialization implementation to support the full feature set.","title":"JacksonJS Decorators"},{"location":"generator/target-typescript-common-features/#arrays","text":"RAML array types are mapped to TypeScript's Array type. They are generated inline and no type aliases are generated. Example Array Generation RAML Type Definition % RAML 1.0 title : Test API types : Item : type : string Items : type : array items : Item Container : items : Items Generated TypeScript Class (simplified) export class Container { items : Array < string > ; constructor ( items : Array < string > ) { this . items = items ; } }","title":"Arrays"},{"location":"generator/target-typescript-common-features/#unions","text":"RAML union types are mapped to the \"nearest common ancestor\" of all individual types in the union, if one exists, in all other cases the union is mapped to TypeScript's Any type. Example Union Generation (Common Aancestor) RAML Type Definition % RAML 1.0 title : Test API types : Device : type : object discriminator : type properties : type : string name : string Phone : type : Device discriminatorValue : phone properties : hasGPS : boolean Tablet : type : Device discriminatorValue : tablet properties : isKeyboardAttached : boolean UnionOfAllDevices : type : (Phone | Tablet) Container : type : object properties : device : UnionOfAllDevices Inline union of types with a common ancestor. Generated TypeScript Class (simplified) export class Container { device : Device ; constructor ( device : Device ) { this . device = device ; } }","title":"Unions"},{"location":"generator/target-typescript-common-features/#generator-options","text":"In addition to the options supported by all code generations targets , this target also supports the following options: Type Generation Options Enable/Disable TypeScript type generation options.","title":"Generator Options"},{"location":"generator/target-typescript-common-features/#supported-options","text":"JacksonJS Decorators Enables or Disables generation of JacksonJS decorators Add Generated Header Enables or Disables adding generation headers to generated types CLI Option Gradle Plugin Properties Type Default -disable jackson-decorators boolean enabled -disable add-generation-header boolean enabled","title":"Supported Options"},{"location":"generator/typescript-sunday/","text":"TypeScript - Sunday Details the specific features of the TypeScript/Sunday code generation target. Generated Types Types generated for the Sunday target are the same as those generated for all TypeScript targets (see Generated Types for TypeScript Targets ) Generated Services Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory interface dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated TypeScript/Sunday Service export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Item > { return this . requestFactory . result ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : [ MediaType .], }, fetchItemReturnType ); } } const fetchItemReturnType : AnyType = [ Item ]; Server-Sent Event Methods Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events. EventSource Service methods marked with the EventSource annotation are generated returning an EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } listenToEvents ( deviceId : string ) : EventSource { return this . requestFactory . events ( { method : 'GET' , pathTemplate : '/events/{deviceId}' , pathParameters : { deviceId , }, acceptTypes : [ MediaType . EventStream ] } ); } } EventStream Service methods marked with the EventStream annotation return a RxJS Observable<T> that is parameterized to the type of event(s) the method produces. Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class import { Device } from './device' ; import { Phone } from './phone' ; import { Tablet } from './tablet' ; export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } listenToEvents ( id : string ) : Observable < Device > { const eventTypes : EventTypes < Device > = { 'phone' : [ Phone ], 'tablet' : [ Tablet ] }; return this . requestFactory . events < Device > ( { method : 'GET' , pathTemplate : '/events/{deviceId}' , pathParameters : { id , }, acceptTypes : [ MediaType . EventStream ] }, eventTypes ); } } Request/Response Only Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (TypeScript) library are Request objects and platform responses are Response objects both types are from the Fetch Web API . Request Only Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Request > { return this . requestFactory . request ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : this.defaultAcceptTypes , }, ); } } Response Only Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Response > { return this . requestFactory . response ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : this.defaultAcceptTypes , }, ); } } Default Media Types The constructors of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses. Request Encoding with Content Types Each client service constructor includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = new API ( requestFactory , [ MediaType . JSON , MediaType . CBOR ], defaultAcceptTypes ) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = new API ( requestFactory , [ MediaType . CBOR , MediaType . JSON ], defaultAcceptTypes ) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used. Response Encoding with Accept Types Sunday will include an Accept header equivalent, in elements and order, to that provided in the service constructor's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = new API ( requestFactory , defaultContentTypes , [ MediaType . CBOR , MediaType . JSON ]) Generator Options In addition to the options supported by all TypeScript code generations targets , this target also supports the following options: None","title":"Sunday"},{"location":"generator/typescript-sunday/#typescript-sunday","text":"Details the specific features of the TypeScript/Sunday code generation target.","title":"TypeScript - Sunday"},{"location":"generator/typescript-sunday/#generated-types","text":"Types generated for the Sunday target are the same as those generated for all TypeScript targets (see Generated Types for TypeScript Targets )","title":"Generated Types"},{"location":"generator/typescript-sunday/#generated-services","text":"Services are generated as classes with a service method for each API endpoint. The services use a RequestFactory interface dependency that performs the network requests and adapts the results. Example Generated Service RAML API Definition #%RAML 1.0 title : Test API mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem responses : 200 : body : Item Generated TypeScript/Sunday Service export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Item > { return this . requestFactory . result ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : [ MediaType .], }, fetchItemReturnType ); } } const fetchItemReturnType : AnyType = [ Item ];","title":"Generated Services"},{"location":"generator/typescript-sunday/#server-sent-event-methods","text":"Service methods that are marked with either of Sunday's Server-Sent Events annotations are generated to return values that allow subscribing to events.","title":"Server-Sent Event Methods"},{"location":"generator/typescript-sunday/#eventsource","text":"Service methods marked with the EventSource annotation are generated returning an EventSource Web API . Example Server-Sent Events Service Method Generation (EventSource) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventSource) : true responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } listenToEvents ( deviceId : string ) : EventSource { return this . requestFactory . events ( { method : 'GET' , pathTemplate : '/events/{deviceId}' , pathParameters : { deviceId , }, acceptTypes : [ MediaType . EventStream ] } ); } }","title":"EventSource"},{"location":"generator/typescript-sunday/#eventstream","text":"Service methods marked with the EventStream annotation return a RxJS Observable<T> that is parameterized to the type of event(s) the method produces. Example Server-Sent Events Service Method Generation (EventStream) RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Event : type : object CallEvent : type : Event MessageEvent : type : Event /events/{deviceId} : get : displayName : listenToEvents (sunday.eventStream) : discriminated responses : 200 : body : text/event-stream : type : (CallEvent | MessageEvent) Generated Service Class import { Device } from './device' ; import { Phone } from './phone' ; import { Tablet } from './tablet' ; export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } listenToEvents ( id : string ) : Observable < Device > { const eventTypes : EventTypes < Device > = { 'phone' : [ Phone ], 'tablet' : [ Tablet ] }; return this . requestFactory . events < Device > ( { method : 'GET' , pathTemplate : '/events/{deviceId}' , pathParameters : { id , }, acceptTypes : [ MediaType . EventStream ] }, eventTypes ); } }","title":"EventStream"},{"location":"generator/typescript-sunday/#requestresponse-only","text":"Service methods can be flagged as \"request\" or \"response\" only using Sunday's RAML extension annoations. These flags will generate service methods that return a platform specific request or response instead of the value defined by the RAML API definition. Note Platform requests in Sunday (TypeScript) library are Request objects and platform responses are Response objects both types are from the Fetch Web API .","title":"Request/Response Only"},{"location":"generator/typescript-sunday/#request-only","text":"Request only service methods return a platform specific request object without executing the remote request. The user can execute the request as is or alter the request first and then execute it. Example Request Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.requestOnly) : true responses : 200 : body : Item Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Request > { return this . requestFactory . request ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : this.defaultAcceptTypes , }, ); } }","title":"Request Only"},{"location":"generator/typescript-sunday/#response-only","text":"Response only service methods return a platform specific response object after executing the remote request. The user can implement custom parsing and handling of the resposne as needed. Example Response Only Service Method Generation RAML API Definition #%RAML 1.0 title : Test API uses : sunday : https://outfoxx.github.io/sunday-generator/sunday.raml mediaType : [ application/json ] types : Item : type : object /items/{id} : get : displayName : fetchItem (sunday.responseOnly) : true responses : 200 : body : Item Generated Service Class export class API { constructor ( public requestFactory : RequestFactory , public defaultContentTypes : Array < MediaType > = [], public defaultAcceptTypes : Array < MediaType > = [ MediaType . JSON ]) { } fetchItem ( id : string ) : Observable < Response > { return this . requestFactory . response ( { method : 'GET' , pathTemplate : '/items/{id}' , pathParameters : { id }, acceptTypes : this.defaultAcceptTypes , }, ); } }","title":"Response Only"},{"location":"generator/typescript-sunday/#default-media-types","text":"The constructors of the generated client services allow specifying the default support and ordering of content & accept types. The order, and elements, of these default lists determines how Sunday encoding requests and decoding responses.","title":"Default Media Types"},{"location":"generator/typescript-sunday/#request-encoding-with-content-types","text":"Each client service constructor includes a parameter defaultContentTypes . The items in this list controls which encodings Sunday will support for encoding requests and the order controls the preference order for selecting the specific request encoding. The items provided in defaultContentTypes are matched to the encodings supported by the requestFactory to choose which encoding will be used to encode request content. Together this allows complete control over request encoding by configuration. Support JSON & CBOR, Preferring JSON Construct the service supporting both JSON and CBOR; preferring JSON . val api = new API ( requestFactory , [ MediaType . JSON , MediaType . CBOR ], defaultAcceptTypes ) If the requestFactory supports JSON , then JSON will be the default encoding used to encode requests; otherwise the CBOR will be used. Support JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR; preferring CBOR . val api = new API ( requestFactory , [ MediaType . CBOR , MediaType . JSON ], defaultAcceptTypes ) If the requestFactory supports CBOR , then CBOR will be the default encoding used to encode requests; otherwise the JSON will be used.","title":"Request Encoding with Content Types"},{"location":"generator/typescript-sunday/#response-encoding-with-accept-types","text":"Sunday will include an Accept header equivalent, in elements and order, to that provided in the service constructor's defaultAcceptTypes parameter. When the server supports content negotiation using the Accept header it will encode responses using the first supproted media type given. Accept JSON & CBOR, Preferring CBOR Construct the service supporting both JSON and CBOR as response encodings; preferring CBOR . val api = new API ( requestFactory , defaultContentTypes , [ MediaType . CBOR , MediaType . JSON ])","title":"Response Encoding with Accept Types"},{"location":"generator/typescript-sunday/#generator-options","text":"In addition to the options supported by all TypeScript code generations targets , this target also supports the following options: None","title":"Generator Options"},{"location":"generator/why-raml/","text":"Why RAML? RAML is a succint and extensible languagee for modeling REST APIs. While we chose to focus on supporting RAML because it's a great language in general, the main reason was due to it's extensibility. Learn more about RAML RAML Specification Extensibility RAML's extensions are defined in RAML which makes them easy to understand and most importantly they are validated during authorship. This ensures authors can get immediate feedback for invalid Sunday's extensions; the same feedback they get when authoring standard RAML features. RAML's extensibility makes it perfect for Sunday which defines numerous extensions to make features like inhertance, nested types, and declaring and using problem response definitions easy to implement. Sunday's RAML extensions . What about OpenAPI? OpenAPI 3.0 has limitations for defining extensions and can at times be very verbose. These issues and more are solved in OpenAPI 3.1. Once parsers and other tools implement the 3.1 specification the Sunday generator plans to support this language as well.","title":"Why?"},{"location":"generator/why-raml/#why-raml","text":"RAML is a succint and extensible languagee for modeling REST APIs. While we chose to focus on supporting RAML because it's a great language in general, the main reason was due to it's extensibility. Learn more about RAML RAML Specification","title":"Why RAML?"},{"location":"generator/why-raml/#extensibility","text":"RAML's extensions are defined in RAML which makes them easy to understand and most importantly they are validated during authorship. This ensures authors can get immediate feedback for invalid Sunday's extensions; the same feedback they get when authoring standard RAML features. RAML's extensibility makes it perfect for Sunday which defines numerous extensions to make features like inhertance, nested types, and declaring and using problem response definitions easy to implement. Sunday's RAML extensions .","title":"Extensibility"},{"location":"generator/why-raml/#what-about-openapi","text":"OpenAPI 3.0 has limitations for defining extensions and can at times be very verbose. These issues and more are solved in OpenAPI 3.1. Once parsers and other tools implement the 3.1 specification the Sunday generator plans to support this language as well.","title":"What about OpenAPI?"},{"location":"sunday-js/","text":"Sunday TYPESCRIPT outfoxx/sunday-js A Sunday client library implementation written in TypeScript, supporting modern web browsers and similar JavaScript environments. Tip While you can use Sunday (TypeScript) to write REST clients manually, Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Sunday Generator Installation Sunday is delivered as standard NPM package that can be consumed by TypeScript and JavaScript projects. Package Name outfoxx/sunday-js Current Release 1.1.0-beta.5 Usage Initializing Service Clients Service clients need to be initialized with an RequestFactory implementation to adapt service methods into network requests. Sunday's standard implementation of RequestFactory , named FetchRequestFactory , is based on the Fetch Web API . You initialize the FetchRequestFactory with a base URL, which can be a URI template if necessary: const requestFactory = new FetchRequestFactory ( \"https://example.com/api/v1\" ); Customizing Requests If needed, you can pass an adapter to the constructor to customize generated requests. The adapter allows you to add authorization headers, change the URL or make any other changes needed to requests generated by the library. const requestFactory = new FetchRequestFactory ( \"https://example.com/api/v1\" , { adapter : ( request ) => { request . headers . set ( \"Authorization\" , `Bearer ${ accessToken } ` ); return Observable . from ( request ); }, }); License Copyright 2020 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"sunday-js/#sunday-typescript-outfoxxsunday-js","text":"A Sunday client library implementation written in TypeScript, supporting modern web browsers and similar JavaScript environments. Tip While you can use Sunday (TypeScript) to write REST clients manually, Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Sunday Generator","title":"Sunday TYPESCRIPT outfoxx/sunday-js  "},{"location":"sunday-js/#installation","text":"Sunday is delivered as standard NPM package that can be consumed by TypeScript and JavaScript projects. Package Name outfoxx/sunday-js Current Release 1.1.0-beta.5","title":"Installation"},{"location":"sunday-js/#usage","text":"","title":"Usage"},{"location":"sunday-js/#initializing-service-clients","text":"Service clients need to be initialized with an RequestFactory implementation to adapt service methods into network requests. Sunday's standard implementation of RequestFactory , named FetchRequestFactory , is based on the Fetch Web API . You initialize the FetchRequestFactory with a base URL, which can be a URI template if necessary: const requestFactory = new FetchRequestFactory ( \"https://example.com/api/v1\" );","title":"Initializing Service Clients"},{"location":"sunday-js/#customizing-requests","text":"If needed, you can pass an adapter to the constructor to customize generated requests. The adapter allows you to add authorization headers, change the URL or make any other changes needed to requests generated by the library. const requestFactory = new FetchRequestFactory ( \"https://example.com/api/v1\" , { adapter : ( request ) => { request . headers . set ( \"Authorization\" , `Bearer ${ accessToken } ` ); return Observable . from ( request ); }, });","title":"Customizing Requests"},{"location":"sunday-js/#license","text":"Copyright 2020 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"sunday-js/api/","text":"API The library has generated documentation that catalogs its complete API: API Documentation","title":"API"},{"location":"sunday-js/api/#api","text":"The library has generated documentation that catalogs its complete API: API Documentation","title":"API"},{"location":"sunday-kotlin/","text":"Sunday KOTLIN outfoxx/sunday-kt A Sunday client library implementation written in Kotlin and supporting the JVM and Android. Tip While you can use Sunday (Kotlin) to write REST clients manually, Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Sunday Generator Implementations Sunday Kotlin is modularized to allow for multiple implementations. Currently the following implementations are available: JDK HTTP Client Uses the native JDK 11 HTTP Client to execute HTTP requests. Square OkHttp Uses Square's OkHttp library (version 4) to execute HTTP requests. OkHttp supports easy configuration of advanced features like certificate pinning and configuration interceptors. Installation Sunday is delivered as a standard Maven library from Maven Central. Gradle (Kotlin DSL) Gradle (Groovy DSL) Maven dependencies { // If using JDK implementation implementation ( \"io.outfoxx.sunday:sunday-jdk:1.0.0-beta.18\" ) // If using OkHttp implementation implementation ( \"io.outfoxx.sunday:sunday-okhttp:1.0.0-beta.18\" ) } dependencies { // If using JDK implementation implementation 'io.outfoxx.sunday:sunday-jdk:1.0.0-beta.18' // If using OkHttp implementation implementation 'io.outfoxx.sunday:sunday-okhttp:1.0.0-beta.18' } <dependencies> <dependency> <groupId> io.outfoxx.sunday </groupId> <!-- If using JDK implementation --> <artifactId> sunday-jdk </artifactId> <!-- If using OkHttp implementation --> <artifactId> sunday-okhttp </artifactId> <version> 1.0.0-beta.18 </version> </dependency> </dependencies> Usage License Copyright 2015 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"sunday-kotlin/#sunday-kotlin-outfoxxsunday-kt","text":"A Sunday client library implementation written in Kotlin and supporting the JVM and Android. Tip While you can use Sunday (Kotlin) to write REST clients manually, Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Sunday Generator","title":"Sunday KOTLIN outfoxx/sunday-kt   "},{"location":"sunday-kotlin/#implementations","text":"Sunday Kotlin is modularized to allow for multiple implementations. Currently the following implementations are available: JDK HTTP Client Uses the native JDK 11 HTTP Client to execute HTTP requests. Square OkHttp Uses Square's OkHttp library (version 4) to execute HTTP requests. OkHttp supports easy configuration of advanced features like certificate pinning and configuration interceptors.","title":"Implementations"},{"location":"sunday-kotlin/#installation","text":"Sunday is delivered as a standard Maven library from Maven Central. Gradle (Kotlin DSL) Gradle (Groovy DSL) Maven dependencies { // If using JDK implementation implementation ( \"io.outfoxx.sunday:sunday-jdk:1.0.0-beta.18\" ) // If using OkHttp implementation implementation ( \"io.outfoxx.sunday:sunday-okhttp:1.0.0-beta.18\" ) } dependencies { // If using JDK implementation implementation 'io.outfoxx.sunday:sunday-jdk:1.0.0-beta.18' // If using OkHttp implementation implementation 'io.outfoxx.sunday:sunday-okhttp:1.0.0-beta.18' } <dependencies> <dependency> <groupId> io.outfoxx.sunday </groupId> <!-- If using JDK implementation --> <artifactId> sunday-jdk </artifactId> <!-- If using OkHttp implementation --> <artifactId> sunday-okhttp </artifactId> <version> 1.0.0-beta.18 </version> </dependency> </dependencies>","title":"Installation"},{"location":"sunday-kotlin/#usage","text":"","title":"Usage"},{"location":"sunday-kotlin/#license","text":"Copyright 2015 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"sunday-kotlin/api/","text":"API The library has KDoc that catalogs its complete API: API Documentation","title":"API"},{"location":"sunday-kotlin/api/#api","text":"The library has KDoc that catalogs its complete API: API Documentation","title":"API"},{"location":"sunday-swift/","text":"Sunday SWIFT outfoxx/sunday-swift A Sunday client library implementation written in Swift and supporting Apple platforms including macOS, iOS, iPadOS, and watchOS. Tip While you can use Sunday (Swift) to write REST clients manually Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Swift Generator Installation Sunday is delivered as a Swift Package Manager package. Package URL https://github.com/outfoxx/sunday-swift.git Current Release 1.0.0-beta.13 Usage After installing the Sunday (Swift) package int the target project, using Sunday only requires importing the module by name. import Sunday Initializing Service Clients Service clients need to be initialized with an RequestFactory implementation to adapt service methods into network requests. Sunday's standard implementation of RequestFactory , named NetworkRequestFactory , is based on Apple's URLSession . You initialize the NetworkRequestFactory with a base URL template: let baseURL = URI . Template ( \"https://example.com/api/v1\" ); let requestFactory = NetworkRequestFactory ( baseURL : baseURL ); Customizing Requests If needed, you can pass an adapter to the initializer to customize generated requests. The adapter allows you to add authorization headers, change the URL or make any other changes needed to requests generated by the library. let baseURI = URI . Template ( \"https://example.com/api/v1\" ); let authorizer = HeaderTokenAuthorizingAdapter ( tokenHeaderType : \"Bearer\" , token : accessToken ) let requestFactory = NetworkRequestFactory ( baseURI , adapter : authorizer ); Certificate Pinning NetworkRequestFactory supports certificate pinning for added security. Passing a ServerTrustPolicyManager to the request factory allows configuring server trust globally or on a per host basis. let baseURI = URI . Template ( \"https://example.com/api/v1\" ); let publicKeys = ServerTrustPolicy . publicKeys ( in : Bundle . main ) let pinnedTrust = ServerTrustPolicyManager ([ \"example.com\" : ServerTrustPolicy . pinPublicKeys ( publicKeys : publicKeys , validateCertificateChain : true , validateHost : true ) ]) let requestFactory = NetworkRequestFactory ( baseURI , serverTrustPolicyManager : pinnedTrust ); License Copyright 2015 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"sunday-swift/#sunday-swift-outfoxxsunday-swift","text":"A Sunday client library implementation written in Swift and supporting Apple platforms including macOS, iOS, iPadOS, and watchOS. Tip While you can use Sunday (Swift) to write REST clients manually Sunday is most useful when generating clietns from API definitions using the Sunday Generator. Learn about Swift Generator","title":"Sunday SWIFT outfoxx/sunday-swift "},{"location":"sunday-swift/#installation","text":"Sunday is delivered as a Swift Package Manager package. Package URL https://github.com/outfoxx/sunday-swift.git Current Release 1.0.0-beta.13","title":"Installation"},{"location":"sunday-swift/#usage","text":"After installing the Sunday (Swift) package int the target project, using Sunday only requires importing the module by name. import Sunday","title":"Usage"},{"location":"sunday-swift/#initializing-service-clients","text":"Service clients need to be initialized with an RequestFactory implementation to adapt service methods into network requests. Sunday's standard implementation of RequestFactory , named NetworkRequestFactory , is based on Apple's URLSession . You initialize the NetworkRequestFactory with a base URL template: let baseURL = URI . Template ( \"https://example.com/api/v1\" ); let requestFactory = NetworkRequestFactory ( baseURL : baseURL );","title":"Initializing Service Clients"},{"location":"sunday-swift/#customizing-requests","text":"If needed, you can pass an adapter to the initializer to customize generated requests. The adapter allows you to add authorization headers, change the URL or make any other changes needed to requests generated by the library. let baseURI = URI . Template ( \"https://example.com/api/v1\" ); let authorizer = HeaderTokenAuthorizingAdapter ( tokenHeaderType : \"Bearer\" , token : accessToken ) let requestFactory = NetworkRequestFactory ( baseURI , adapter : authorizer );","title":"Customizing Requests"},{"location":"sunday-swift/#certificate-pinning","text":"NetworkRequestFactory supports certificate pinning for added security. Passing a ServerTrustPolicyManager to the request factory allows configuring server trust globally or on a per host basis. let baseURI = URI . Template ( \"https://example.com/api/v1\" ); let publicKeys = ServerTrustPolicy . publicKeys ( in : Bundle . main ) let pinnedTrust = ServerTrustPolicyManager ([ \"example.com\" : ServerTrustPolicy . pinPublicKeys ( publicKeys : publicKeys , validateCertificateChain : true , validateHost : true ) ]) let requestFactory = NetworkRequestFactory ( baseURI , serverTrustPolicyManager : pinnedTrust );","title":"Certificate Pinning"},{"location":"sunday-swift/#license","text":"Copyright 2015 Outfox, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"sunday-swift/api/","text":"API The library has generated documentation that catalogs its complete API: API Documentation","title":"API"},{"location":"sunday-swift/api/#api","text":"The library has generated documentation that catalogs its complete API: API Documentation","title":"API"}]}